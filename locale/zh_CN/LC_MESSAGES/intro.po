# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version:  django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-25 11:41+0800\n"
"PO-Revision-Date: 2016-07-07 06:04+0000\n"
"Last-Translator: 吴彬 <xiake21x@qq.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/django/django-"
"docs/language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.2.0\n"

#: ../../intro/contributing.txt:3
msgid "Writing your first patch for Django"
msgstr "编写你的第一个Django补丁"

#: ../../intro/contributing.txt:6
msgid "Introduction"
msgstr "介绍"

#: ../../intro/contributing.txt:8
msgid ""
"Interested in giving back to the community a little? Maybe you've found a"
" bug in Django that you'd like to see fixed, or maybe there's a small "
"feature you want added."
msgstr "想为Django社区做一点贡献？你也许发现了一个想修复的bug，或者你想添加一个新的功能。"

#: ../../intro/contributing.txt:12
msgid ""
"Contributing back to Django itself is the best way to see your own "
"concerns addressed. This may seem daunting at first, but it's really "
"pretty simple. We'll walk you through the entire process, so you can "
"learn by example."
msgstr "为Django作贡献这件事本身就是使你的顾虑得到解决的最好方式。一开始这可能会使你怯步，但事实上是很简单的。整个过程中我们会一步一步为你解说，所以你可以通过例子学习。"

#: ../../intro/contributing.txt:17
msgid "Who's this tutorial for?"
msgstr "这个教程适合谁？"

#: ../../intro/contributing.txt:21
msgid ""
"If you are looking for a reference on how to submit patches, see the "
":doc:`/internals/contributing/writing-code/submitting-patches` "
"documentation."
msgstr ""
"如果你正在寻找一个关于如何提交补丁的参考,请查看 :doc:`/internals/contributing/writing-code"
"/submitting-patches` 文档."

#: ../../intro/contributing.txt:25
msgid ""
"For this tutorial, we expect that you have at least a basic understanding"
" of how Django works. This means you should be comfortable going through "
"the existing tutorials on :doc:`writing your first Django "
"app</intro/tutorial01>`. In addition, you should have a good "
"understanding of Python itself. But if you don't, `Dive Into Python`__ is"
" a fantastic (and free) online book for beginning Python programmers."
msgstr ""
"使用教程前，我们希望你至少对于Django的运行方式有基础的了解. 这意味着你可以很容易地 :doc:`写你自己的 Django "
"app</intro/tutorial01>` . 时使用教程, 除此之外，你应该对于Python本身有很好的了解。 如果您并不太了解, "
"我们为您推荐  `Dive Into Python`__ 对于初次使用Python的程序员来说这是一本很棒(而且免费)的在线电子书。"

#: ../../intro/contributing.txt:32
msgid ""
"Those of you who are unfamiliar with version control systems and Trac "
"will find that this tutorial and its links include just enough "
"information to get started. However, you'll probably want to read some "
"more about these different tools if you plan on contributing to Django "
"regularly."
msgstr ""
"那些不熟悉版本控制系统及缺陷跟踪的朋友可以查看这个教程,这个连接包含了正好足够的信息. "
"如果你打算定期的贡献Django,然而,你很可能像更多的阅读关于这些不同工具的信息."

#: ../../intro/contributing.txt:37
msgid ""
"For the most part though, this tutorial tries to explain as much as "
"possible, so that it can be of use to the widest audience."
msgstr "当然对于其中的大部分内容，Django会尽可能做出解释以帮助广大的读者。"

#: ../../intro/contributing.txt:40 ../../intro/tutorial01.txt:35
msgid "Where to get help:"
msgstr "从哪里获得帮助："

#: ../../intro/contributing.txt:42
msgid ""
"If you're having trouble going through this tutorial, please post a "
"message to |django-developers| or drop by `#django-dev on "
"irc.freenode.net`__ to chat with other Django users who might be able to "
"help."
msgstr ""
"如果你在使用本教程时遇到困难, 你可以发送信息给 | django-developers | 或 登陆 `#django-dev on "
"irc.freenode.net`__ 向其他Django使用者需求帮助。"

#: ../../intro/contributing.txt:50
msgid "What does this tutorial cover?"
msgstr "这个指南涵盖哪些内容？"

#: ../../intro/contributing.txt:52
msgid ""
"We'll be walking you through contributing a patch to Django for the first"
" time. By the end of this tutorial, you should have a basic understanding"
" of both the tools and the processes involved. Specifically, we'll be "
"covering the following:"
msgstr "我们将指导你贡献你的第一个Django补丁,在本教程完毕时,你将对相关工具及流程有一个基本的认识,特别的,我们将覆盖一下内容:"

#: ../../intro/contributing.txt:56
msgid "Installing Git."
msgstr "安装Git."

#: ../../intro/contributing.txt:57
msgid "How to download a development copy of Django."
msgstr "如何下载Django的开发版"

#: ../../intro/contributing.txt:58
msgid "Running Django's test suite."
msgstr "运行Django的测试套件."

#: ../../intro/contributing.txt:59
msgid "Writing a test for your patch."
msgstr "为你的补丁写一个测试."

#: ../../intro/contributing.txt:60
msgid "Writing the code for your patch."
msgstr "为你的补丁写代码."

#: ../../intro/contributing.txt:61
msgid "Testing your patch."
msgstr "测试你的补丁."

#: ../../intro/contributing.txt:62
msgid "Generating a patch file for your changes."
msgstr "为你的更改生成一个补丁文件."

#: ../../intro/contributing.txt:63
msgid "Where to look for more information."
msgstr "在哪里查找更多的信息."

#: ../../intro/contributing.txt:65
msgid ""
"Once you're done with the tutorial, you can look through the rest of "
":doc:`Django's documentation on "
"contributing</internals/contributing/index>`. It contains lots of great "
"information and is a must read for anyone who'd like to become a regular "
"contributor to Django. If you've got questions, it's probably got the "
"answers."
msgstr ""
"一旦你完成了这份教程, 你可以浏览剩下的 :doc:`Django's documentation on "
"contributing</internals/contributing/index>`.它包含了大量信息。任何想成为Django的正式贡献者必须去阅读它。如果你有问题，它也许会给你答案."

#: ../../intro/contributing.txt:71
msgid "Python 3 required!"
msgstr "需求 Python 3 !"

#: ../../intro/contributing.txt:73
msgid ""
"This tutorial assumes you are using Python 3. Get the latest version at "
"`Python's download page <https://www.python.org/download/>`_ or with your"
" operating system's package manager."
msgstr ""
"本教程假设您正在使用 Python 3. 获得最新版本 `Python 的下载页 "
"<https://www.python.org/download/>`_ 或使用您的操作系统的包管理器进行安装。"

#: ../../intro/contributing.txt:77 ../../intro/contributing.txt:99
#: ../../intro/contributing.txt:144 ../../intro/contributing.txt:180
msgid "For Windows users"
msgstr "Windows 用户"

#: ../../intro/contributing.txt:79
msgid ""
"When installing Python on Windows, make sure you check the option \"Add "
"python.exe to Path\", so that it is always available on the command line."
msgstr ""
"当在Windows 上安装Python, 确保在环境变量path中 \"添加 python.exe 的路径\", "
"这样才可以让它总是可以在命令行下运行。"

#: ../../intro/contributing.txt:83
msgid "Code of Conduct"
msgstr "代码规范"

#: ../../intro/contributing.txt:85
msgid ""
"As a contributor, you can help us keep the Django community open and "
"inclusive. Please read and follow our `Code of Conduct "
"<https://www.djangoproject.com/conduct/>`_."
msgstr ""
"作为一个贡献者, 你可以帮助我们保持Django的社区开放性和包容性. 请仔细阅读并遵守我们的 `Code of Conduct "
"<https://www.djangoproject.com/conduct/>`_."

#: ../../intro/contributing.txt:89
msgid "Installing Git"
msgstr "安装Git."

#: ../../intro/contributing.txt:91
msgid ""
"For this tutorial, you'll need Git installed to download the current "
"development version of Django and to generate patch files for the changes"
" you make."
msgstr "使用教程前，你需要安装好Git，下载Django的最新开发版本并且为你作出的改变生成补丁文件"

#: ../../intro/contributing.txt:95
msgid ""
"To check whether or not you have Git installed, enter ``git`` into the "
"command line. If you get messages saying that this command could not be "
"found, you'll have to download and install it, see `Git's download "
"page`__."
msgstr ""
"要检查您是否已经安装的Git, 输入 ``git`` 进入命令行. 如果你得到的消息说，这个命令无法找到, 你必须下载并安装它, 查看 `Git "
"下载页`__."

#: ../../intro/contributing.txt:101
msgid ""
"When installing Git on Windows, it is recommended that you pick the \"Git"
" Bash\" option so that Git runs in its own shell. This tutorial assumes "
"that's how you have installed it."
msgstr ""
"在Windows上安装Git, 我们推荐选择 \"Git Bash\" 选项， 以便 Git 能在shell下正常运行. "
"本教程假定你这就是这样安装的。"

#: ../../intro/contributing.txt:105
msgid ""
"If you're not that familiar with Git, you can always find out more about "
"its commands (once it's installed) by typing ``git help`` into the "
"command line."
msgstr "如果你还不熟悉 Git, 你可以在命令行下输入 ``git help``  了解更多关于Git命令的使用方法 (确认已安装) "

#: ../../intro/contributing.txt:111
msgid "Getting a copy of Django's development version"
msgstr "获得一个Django开发版本的拷贝"

#: ../../intro/contributing.txt:113
msgid ""
"The first step to contributing to Django is to get a copy of the source "
"code. From the command line, use the ``cd`` command to navigate to the "
"directory where you'll want your local copy of Django to live."
msgstr "为Django贡献的第一步就是获取源代码复本. 在命令行离, 使用 ``cd`` 命令进入你想要保存Django的目录"

#: ../../intro/contributing.txt:117
msgid "Download the Django source code repository using the following command:"
msgstr "使用下面的命令来下载Django的源码库:"

#: ../../intro/contributing.txt:123
msgid ""
"Now that you have a local copy of Django, you can install it just like "
"you would install any package using ``pip``. The most convenient way to "
"do so is by using a *virtual environment* (or virtualenv) which is a "
"feature built into Python that allows you to keep a separate directory of"
" installed packages for each of your projects so that they don't "
"interfere with each other."
msgstr ""
"现在，你有Django的本地副本, 你可以安装它，就像你使用 ``pip`` 安装软件包. 最方便的方式是通过使用 *virtual "
"environment*  (or virtualenv)这样做， "
"这是内置到Python中的功能，可以让你保持对每个项目安装的软件包的一个单独的目录，以便它们不会互相干扰。"

#: ../../intro/contributing.txt:129
msgid ""
"It's a good idea to keep all your virtualenvs in one place, for example "
"in ``.virtualenvs/`` in your home directory. Create it if it doesn't "
"exist yet:"
msgstr "这是一个好主意，让你所有的 virtualenvs 保存在同一个地方, 例如 ``.virtualenvs/`` 你的主目录. 如果不存在？创建它："

#: ../../intro/contributing.txt:136
msgid "Now create a new virtualenv by running:"
msgstr "现在创建新的虚拟运行环境"

#: ../../intro/contributing.txt:142
msgid "The path is where the new environment will be saved on your computer."
msgstr "这个新的环境的路径将被保存在你的电脑上。"

#: ../../intro/contributing.txt:146
msgid ""
"Using the built-in ``venv`` module will not work if you are also using "
"the Git Bash shell on Windows, since activation scripts are only created "
"for the system shell (``.bat``) and PowerShell (``.ps1``). Use the "
"``virtualenv`` package instead:"
msgstr ""
"使用内置的 ``venv`` 模块不能工作，你也可以使用在Windows上使用 Git Bash shell, "
"因为激活脚本只是创建了系统shell (``.bat``) 和 PowerShell (``.ps1``). 使用 ``virtualenv`` "
"软件包安装:"

#: ../../intro/contributing.txt:156
msgid "For Ubuntu users"
msgstr "Ubuntu 用户"

#: ../../intro/contributing.txt:158
msgid ""
"On some versions of Ubuntu the above command might fail. Use the "
"``virtualenv`` package instead, first making sure you have ``pip3``:"
msgstr "在Ubuntu的一些版本上使用 ``virtualenv`` 软件包安装可能会失败,首先要确保你有``pip3``:"

#: ../../intro/contributing.txt:168
msgid "The final step in setting up your virtualenv is to activate it:"
msgstr "最后一步是激活你的 virtualenv 设置:"

#: ../../intro/contributing.txt:174
msgid ""
"If the ``source`` command is not available, you can try using a dot "
"instead:"
msgstr "如果 ``source`` 命令不可用, 你可以尝试使用一个点 . 来代替:"

#: ../../intro/contributing.txt:182
msgid "To activate your virtualenv on Windows, run:"
msgstr "在Windows上激活你的 virtualenv，运行:"

#: ../../intro/contributing.txt:188
msgid ""
"You have to activate the virtualenv whenever you open a new terminal "
"window. virtualenvwrapper__ is a useful tool for making this more "
"convenient."
msgstr "每当你打开一个新的终端窗口，你必须激活 virtualenv. virtualenvwrapper__ 是为了让这种操作更方便的有用工具。"

#: ../../intro/contributing.txt:193
msgid ""
"Anything you install through ``pip`` from now on will be installed in "
"your new virtualenv, isolated from other environments and system-wide "
"packages. Also, the name of the currently activated virtualenv is "
"displayed on the command line to help you keep track of which one you are"
" using. Go ahead and install the previously cloned copy of Django:"
msgstr ""
"从现在开始你通过``pip``安装任何软件包将被安装在新的 virtualenv "
"，来自其他环境和系统级封装隔离。此外，在命令行上显示当前激活的virtualenv的名称，以帮助您跟踪您正在使用那个环境。来吧，安装Django先前克隆副本："

#: ../../intro/contributing.txt:203
msgid ""
"The installed version of Django is now pointing at your local copy. You "
"will immediately see any changes you make to it, which is of great help "
"when writing your first patch."
msgstr "现在 Django安装的版本是指向您的本地副本"

#: ../../intro/contributing.txt:208
msgid "Rolling back to a previous revision of Django"
msgstr "回滚至你之前的Django版本"

#: ../../intro/contributing.txt:210
msgid ""
"For this tutorial, we'll be using ticket :ticket:`24788` as a case study,"
" so we'll rewind Django's version history in git to before that ticket's "
"patch was applied. This will allow us to go through all of the steps "
"involved in writing that patch from scratch, including running Django's "
"test suite."
msgstr ""
"这个教程中，我们使用 :ticket:`24788` 问题来作为学习用例, "
"所以我们要把git中Django的版本回滚到这个问题的补丁没有提交之前。 "
"这样的话我们就可以参与到从草稿到补丁的所有过程，包括运行Django的测试套件。"

#: ../../intro/contributing.txt:215
msgid ""
"**Keep in mind that while we'll be using an older revision of Django's "
"trunk for the purposes of the tutorial below, you should always use the "
"current development revision of Django when working on your own patch for"
" a ticket!**"
msgstr "请记住，我们将用Django的老版本来到达学习的目的，通常情况下你应当使用当前最新的开发版本来提交补丁！。"

#: ../../intro/contributing.txt:221
msgid ""
"The patch for this ticket was written by Paweł Marczewski, and it was "
"applied to Django as `commit 4df7e8483b2679fc1cba3410f08960bac6f51115`__."
" Consequently, we'll be using the revision of Django just prior to that, "
"`commit 4ccfc4439a7add24f8db4ef3960d02ef8ae09887`__."
msgstr ""
"这个补丁由 Paweł Marczewski 开发，并 Git  提交到 Django 源码 `提交 "
"4df7e8483b2679fc1cba3410f08960bac6f51115`__. 因此, 我们要回到补丁提交之前的版本号， `提交 "
"4ccfc4439a7add24f8db4ef3960d02ef8ae09887`__."

#: ../../intro/contributing.txt:229
msgid ""
"Navigate into Django's root directory (that's the one that contains "
"``django``, ``docs``, ``tests``, ``AUTHORS``, etc.). You can then check "
"out the older revision of Django that we'll be using in the tutorial "
"below:"
msgstr ""
"首先打开Django源码的根目录 (这个目录包含了 ``django``, ``docs``, ``tests``, ``AUTHORS``, "
"etc.). 然后你你可以根据下面的教程check out老版本的Django："

#: ../../intro/contributing.txt:238
msgid "Running Django's test suite for the first time"
msgstr "首先运行 Django 的测试套件"

#: ../../intro/contributing.txt:240
msgid ""
"When contributing to Django it's very important that your code changes "
"don't introduce bugs into other areas of Django. One way to check that "
"Django still works after you make your changes is by running Django's "
"test suite. If all the tests still pass, then you can be reasonably sure "
"that your changes haven't completely broken Django. If you've never run "
"Django's test suite before, it's a good idea to run it once beforehand "
"just to get familiar with what its output is supposed to look like."
msgstr ""
"当你贡献代码给Django的时候，一个非常重要的问题就是你修改的代码不要给其他部分引入新的bug。 "
"有个办法可以在你更改代码之后检查Django是否能正常工作，就是运行Django的测试套件。如果所有的测试用例都通过，你就有理由相信你的改动完全没有破坏Django。如果你从来没有运行过Django的测试套件，那么比较好的做法是事先运行一遍，熟悉下正常情况下应该输出什么结果。"

#: ../../intro/contributing.txt:248
msgid ""
"Before running the test suite, install its dependencies by first "
"``cd``-ing into the Django ``tests/`` directory and then running:"
msgstr "运行测试之前，先 ``cd`` ，进入Django的 ``test/`` 目录，然后运行安装其依赖关系："

#: ../../intro/contributing.txt:255
msgid ""
"Now we are ready to run the test suite. If you're using GNU/Linux, Mac OS"
" X or some other flavor of Unix, run:"
msgstr "现在，我们已经准备好运行测试套件，如果你是用GNU/Linux, Mac OS X或者其你喜欢的其他Unix系统，执行："

#: ../../intro/contributing.txt:262
msgid ""
"Now sit back and relax. Django's entire test suite has over 9,600 "
"different tests, so it can take anywhere from 5 to 15 minutes to run, "
"depending on the speed of your computer."
msgstr "现在坐下来放松一下. Django的整个测试套件有超过9,600种不同的测试,所以它运行时间需要5到15分钟,这取决于你的电脑的速度。"

#: ../../intro/contributing.txt:266
msgid ""
"While Django's test suite is running, you'll see a stream of characters "
"representing the status of each test as it's run. ``E`` indicates that an"
" error was raised during a test, and ``F`` indicates that a test's "
"assertions failed. Both of these are considered to be test failures. "
"Meanwhile, ``x`` and ``s`` indicated expected failures and skipped tests,"
" respectively. Dots indicate passing tests."
msgstr ""
"Django的测试套件运行时,您将看到一个字符流代表每个测试的运行的状态. ``E`` 表示测试中出现异常, 和 ``F`` 表示断言失败. "
"这两种情况都被认为测试失败, ``x`` 和 ``s`` 分别表示与期望结果不同和跳过测试, 点表示测试通过。"

#: ../../intro/contributing.txt:273
#, fuzzy
msgid ""
"Skipped tests are typically due to missing external libraries required to"
" run the test; see :ref:`running-unit-tests-dependencies` for a list of "
"dependencies and be sure to install any for tests related to the changes "
"you are making (we won't need any for this tutorial). Some tests are "
"specific to a particular database backend and will be skipped if not "
"testing with that backend. SQLite is the database backend for the default"
" settings. To run the tests using a different backend, see :ref:`running-"
"unit-tests-settings`."
msgstr ""
"跳过测试主要由缺少测试所需的外部库引起; 查看 :ref:`running-unit-tests-dependencies` "
"获取测所需依赖包，并确保安装由于代码修改造成的新依赖包 (这篇教程不需要额外安装依赖包)."

#: ../../intro/contributing.txt:281
msgid ""
"Once the tests complete, you should be greeted with a message informing "
"you whether the test suite passed or failed. Since you haven't yet made "
"any changes to Django's code, the entire test suite **should** pass. If "
"you get failures or errors make sure you've followed all of the previous "
"steps properly. See :ref:`running-unit-tests` for more information."
msgstr ""
"当测试执行完毕后，得到反馈信息显示测试已通过，或者测试失败。 因为还没有对 Django 的源码做任何修改, 所有的测试用例 "
"**应该should** 测试通过. 如果测试失败或出现错误，回头确认以上执行操作是否正确. 查看 :ref:`running-unit-"
"tests` 获取更多信息。"

#: ../../intro/contributing.txt:287
msgid ""
"Note that the latest Django trunk may not always be stable. When "
"developing against trunk, you can check `Django's continuous integration "
"builds`__ to determine if the failures are specific to your machine or if"
" they are also present in Django's official builds. If you click to view "
"a particular build, you can view the \"Configuration Matrix\" which shows"
" failures broken down by Python version and database backend."
msgstr ""
"注意最新版本 Django 分支不总稳定。当在分支上开发时, 你可以查看代码持续集成构建页面的信息 `Django's continuous "
"integration builds`__ 来判断测试错误只在你指定的电脑上发生，还是官方版本中也存在该错误. 如果点击某个构建信息, 可以通过 "
"\"Configuration Matrix\" 查看错误发生时 Python 以及后端数据库的信息。"

#: ../../intro/contributing.txt:298
msgid ""
"For this tutorial and the ticket we're working on, testing against SQLite"
" is sufficient, however, it's possible (and sometimes necessary) to "
":ref:`run the tests using a different database <running-unit-tests-"
"settings>`."
msgstr ""
"在本教程以及所用分支中, 测试使用数据库 SQLite 即可,然而在某些情况下需要 (有时需要) to :ref:`运行测试更多不同的数据库 "
"<running-unit-tests-settings>`."

#: ../../intro/contributing.txt:304
msgid "Writing some tests for your ticket"
msgstr "为你的ticket写一些测试用例"

#: ../../intro/contributing.txt:306
msgid ""
"In most cases, for a patch to be accepted into Django it has to include "
"tests. For bug fix patches, this means writing a regression test to "
"ensure that the bug is never reintroduced into Django later on. A "
"regression test should be written in such a way that it will fail while "
"the bug still exists and pass once the bug has been fixed. For patches "
"containing new features, you'll need to include tests which ensure that "
"the new features are working correctly. They too should fail when the new"
" feature is not present, and then pass once it has been implemented."
msgstr ""
"大多数情况下，Django 的补丁必需包含测试。Bug 修复补丁的测试是一个回归测试，确保该 Bug 不会再次在 Django "
"中出现。该测试应该在 Bug 存在时测试失败，在 Bug "
"已经修复后通过测试。新功能补丁的测试必须验证新功能是否正常运行。新功能的测试将在功能正常时通过测试，功能未执行时测试失败。"

#: ../../intro/contributing.txt:315
msgid ""
"A good way to do this is to write your new tests first, before making any"
" changes to the code. This style of development is called `test-driven "
"development`__ and can be applied to both entire projects and single "
"patches. After writing your tests, you then run them to make sure that "
"they do indeed fail (since you haven't fixed that bug or added that "
"feature yet). If your new tests don't fail, you'll need to fix them so "
"that they do. After all, a regression test that passes regardless of "
"whether a bug is present is not very helpful at preventing that bug from "
"reoccurring down the road."
msgstr ""
"最好的方式是在修改代码之前写测试单元代码. 这种开发风格叫做 `测试驱动开发`__ "
"被应用在项目开发和单一补丁开发过程中。测试单元编写完毕后，执行测试单元，此时测试失败(因为目前还没有修复 BuG 或 "
"添加新功能)，如果测试成功通过，你需要重新修改测试单元保证测试失败。然而测试单元并没有阻止 BUG 发生的作用。"

#: ../../intro/contributing.txt:324
msgid "Now for our hands-on example."
msgstr "现在我们的操作示例。"

#: ../../intro/contributing.txt:329
msgid "Writing some tests for ticket #24788"
msgstr "为 ticket #24788 写测试"

#: ../../intro/contributing.txt:331
msgid ""
"Ticket :ticket:`24788` proposes a small feature addition: the ability to "
"specify the class level attribute ``prefix`` on Form classes, so that::"
msgstr "Ticket :ticket:`24788` 提议增加小特性: 为表单类指定类级别的属性``prefix``，以便::"

#: ../../intro/contributing.txt:338
msgid ""
"In order to resolve this ticket, we'll add a ``prefix`` attribute to the "
"``BaseForm`` class. When creating instances of this class, passing a "
"prefix to the ``__init__()`` method will still set that prefix on the "
"created instance. But not passing a prefix (or passing ``None``) will use"
" the class-level prefix. Before we make those changes though, we're going"
" to write a couple tests to verify that our modification functions "
"correctly and continues to function correctly in the future."
msgstr ""

#: ../../intro/contributing.txt:346
msgid ""
"Navigate to Django's ``tests/forms_tests/tests/`` folder and open the "
"``test_forms.py`` file. Add the following code on line 1674 right before "
"the ``test_forms_with_null_boolean`` function::"
msgstr ""

#: ../../intro/contributing.txt:362
msgid ""
"This new test checks that setting a class level prefix works as expected,"
" and that passing a ``prefix`` parameter when creating an instance still "
"works too."
msgstr ""

#: ../../intro/contributing.txt:365
msgid "But this testing thing looks kinda hard..."
msgstr "但这种测试事情看起来有点硬..."

#: ../../intro/contributing.txt:367
msgid ""
"If you've never had to deal with tests before, they can look a little "
"hard to write at first glance. Fortunately, testing is a *very* big "
"subject in computer programming, so there's lots of information out "
"there:"
msgstr ""

#: ../../intro/contributing.txt:371
msgid ""
"A good first look at writing tests for Django can be found in the "
"documentation on :doc:`/topics/testing/overview`."
msgstr ""

#: ../../intro/contributing.txt:373
msgid ""
"Dive Into Python (a free online book for beginning Python developers) "
"includes a great `introduction to Unit Testing`__."
msgstr ""

#: ../../intro/contributing.txt:375
msgid ""
"After reading those, if you want something a little meatier to sink your "
"teeth into, there's always the `Python unittest documentation`__."
msgstr ""

#: ../../intro/contributing.txt:382
msgid "Running your new test"
msgstr "运行你的新测试"

#: ../../intro/contributing.txt:384
msgid ""
"Remember that we haven't actually made any modifications to ``BaseForm`` "
"yet, so our tests are going to fail. Let's run all the tests in the "
"``forms_tests`` folder to make sure that's really what happens. From the "
"command line, ``cd`` into the Django ``tests/`` directory and run:"
msgstr ""

#: ../../intro/contributing.txt:393
msgid ""
"If the tests ran correctly, you should see one failure corresponding to "
"the test method we added. If all of the tests passed, then you'll want to"
" make sure that you added the new test shown above to the appropriate "
"folder and class."
msgstr ""

#: ../../intro/contributing.txt:398
msgid "Writing the code for your ticket"
msgstr ""

#: ../../intro/contributing.txt:400
msgid ""
"Next we'll be adding the functionality described in ticket "
":ticket:`24788` to Django."
msgstr ""

#: ../../intro/contributing.txt:404
msgid "Writing the code for ticket #24788"
msgstr "为标签 #24788 编写代码"

#: ../../intro/contributing.txt:406
msgid ""
"Navigate to the ``django/django/forms/`` folder and open the ``forms.py``"
" file. Find the ``BaseForm`` class on line 72 and add the ``prefix`` "
"class attribute right after the ``field_order`` attribute::"
msgstr ""
"进入到 ``django/django/forms/`` 文件夹并打开 ``forms.py`` "
"文件。查找第72行的``BaseForm``类和``field_order``属性之后添加``prefix``类属性::"

#: ../../intro/contributing.txt:419
msgid "Verifying your test now passes"
msgstr "确保测试通过"

#: ../../intro/contributing.txt:421
msgid ""
"Once you're done modifying Django, we need to make sure that the tests we"
" wrote earlier pass, so we can see whether the code we wrote above is "
"working correctly. To run the tests in the ``forms_tests`` folder, ``cd``"
" into the Django ``tests/`` directory and run:"
msgstr ""
"修改 Django 源码后，我们通过之前编写的测试方法来验证源码修改是否工作正常. 运行测试 ``forms_tests`` "
"目录下所有的测试方法, ``cd`` 进入到 Django的 ``tests/`` 目录然后在运行:"

#: ../../intro/contributing.txt:430
msgid ""
"Oops, good thing we wrote those tests! You should still see one failure "
"with the following exception::"
msgstr "哦,好事是我们写了这些测试! 但仍然收到一个测试异常::"

#: ../../intro/contributing.txt:435
msgid ""
"We forgot to add the conditional statement in the ``__init__`` method. Go"
" ahead and change ``self.prefix = prefix`` that is now on line 87 of "
"``django/forms/forms.py``, adding a conditional statement::"
msgstr ""
"我们忘了 '__init__' 方法中添加条件语句。往前走并更改 'self.prefix = prefix' 现在这在一行 87 "
"'django/forms/forms.py ' 中，添加一个条件语句::"

#: ../../intro/contributing.txt:442
msgid ""
"Re-run the tests and everything should pass. If it doesn't, make sure you"
" correctly modified the ``BaseForm`` class as shown above and copied the "
"new test correctly."
msgstr ""
"重新运行测试方法正常会通过测试. 如果没有通过测试, 请重新确认上面提到的类 ``BaseForm`` "
"以及新添加的测试方法是否被正确复制到指定位置。"

#: ../../intro/contributing.txt:447
msgid "Running Django's test suite for the second time"
msgstr "再次运行Django 的测试套件"

#: ../../intro/contributing.txt:449
msgid ""
"Once you've verified that your patch and your test are working correctly,"
" it's a good idea to run the entire Django test suite just to verify that"
" your change hasn't introduced any bugs into other areas of Django. While"
" successfully passing the entire test suite doesn't guarantee your code "
"is bug free, it does help identify many bugs and regressions that might "
"otherwise go unnoticed."
msgstr ""
"如果已经确认补丁以及测试结果都正常，现在是时候运行 Django 完整的测试用例，验证你的修改是否对 Django 的其他部分造成新的 Bug。 "
"虽然测试用例帮助识别容易被人忽略的错误，但测试通过并不能保证完全没有 Bug 存在。"

#: ../../intro/contributing.txt:455
msgid ""
"To run the entire Django test suite, ``cd`` into the Django ``tests/`` "
"directory and run:"
msgstr "运行 Django 完整的测试用例，``cd`` 进入 Django下的  ``tests/`` 目录并运行:"

#: ../../intro/contributing.txt:462
msgid "As long as you don't see any failures, you're good to go."
msgstr "只要没有看到测试异常，你可以继续下一步骤。"

#: ../../intro/contributing.txt:465
msgid "Writing Documentation"
msgstr "书写文档"

#: ../../intro/contributing.txt:467
msgid ""
"This is a new feature, so it should be documented. Add the following "
"section on line 1068 (at the end of the file) of "
"``django/docs/ref/forms/api.txt``::"
msgstr ""
"这个新功能信息应该被记录到文档. 在 1068行 上添加以下部分内容 (在文本末)  "
"``django/docs/ref/forms/api.txt``::"

#: ../../intro/contributing.txt:480
msgid ""
"Since this new feature will be in an upcoming release it is also added to"
" the release notes for Django 1.9, on line 164 under the \"Forms\" "
"section in the file ``docs/releases/1.9.txt``::"
msgstr ""
"因此这一新功能将在未来的Django "
"1.9版本中也加入到注释，在164行文件``docs/releases/1.9.txt``在“Forms”部分::"

#: ../../intro/contributing.txt:487
msgid ""
"For more information on writing documentation, including an explanation "
"of what the ``versionadded`` bit is all about, see "
":doc:`/internals/contributing/writing-documentation`. That page also "
"includes an explanation of how to build a copy of the documentation "
"locally, so you can preview the HTML that will be generated."
msgstr ""
"关于 ``versionadded`` 的解释以及文档编写的更多信息，请参考 :doc:`/internals/contributing"
"/writing-documentation` . 这个页面还介绍了怎么在本地重新生成一份文档，你可以查看新生成的 HTML 文档页面."

#: ../../intro/contributing.txt:494
msgid "Generating a patch for your changes"
msgstr "为你的修改生成补丁"

#: ../../intro/contributing.txt:496
msgid ""
"Now it's time to generate a patch file that can be uploaded to Trac or "
"applied to another copy of Django. To get a look at the content of your "
"patch, run the following command:"
msgstr "现在是时候生成一个补丁文件，这个补丁文件可以上传到 Trac 或者更新到其他 Django。 运行下面这个命令来查看你的补丁内容："

#: ../../intro/contributing.txt:504
msgid ""
"This will display the differences between your current copy of Django "
"(with your changes) and the revision that you initially checked out "
"earlier in the tutorial."
msgstr "这里显示的内容为当前代码与 check out 时候的代码变化，即之前的Django副本代码对所做修改前后的变化(你的更改)"

#: ../../intro/contributing.txt:508
msgid ""
"Once you're done looking at the patch, hit the ``q`` key to exit back to "
"the command line. If the patch's content looked okay, you can run the "
"following command to save the patch file to your current working "
"directory:"
msgstr "在浏览补丁内容后按 ``q``  键退出命令行。如果你的补丁内容看起来正常，运行下面这个命令，在当前目录生成补丁文件："

#: ../../intro/contributing.txt:516
msgid ""
"You should now have a file in the root Django directory called "
"``24788.diff``. This patch file contains all your changes and should look"
" this:"
msgstr "在 Django 的根目录生成补丁文件 ``24788.diff`` 。这个补丁文件包含所有的代码变动信息，看起来如下："

#: ../../intro/contributing.txt:600
msgid "So what do I do next?"
msgstr "那么下面我要做什么?"

#: ../../intro/contributing.txt:602
msgid ""
"Congratulations, you've generated your very first Django patch! Now that "
"you've got that under your belt, you can put those skills to good use by "
"helping to improve Django's codebase. Generating patches and attaching "
"them to Trac tickets is useful, however, since we are using git - "
"adopting a more :doc:`git oriented workflow </internals/contributing"
"/writing-code/working-with-git>` is recommended."
msgstr ""
"恭喜，你已经生成了你的第一个 Django 补丁 ！现在你已经明白了整个过程，你可以好好利用这些技能帮助改善Django的代码库. "
"生成补丁和发送到 Trac 让人使用，然而我们推荐使用 :doc:`面向 git 的工作流 </internals/contributing"
"/writing-code/working-with-git>` 。"

#: ../../intro/contributing.txt:609
msgid ""
"Since we never committed our changes locally, perform the following to "
"get your git branch back to a good starting point:"
msgstr "目前我们没有在本地对仓储做提交操作，我们可以通过下面这个命令放弃修改并回到最原始 Django 代码状态。"

#: ../../intro/contributing.txt:618
msgid "More information for new contributors"
msgstr "针对新贡献者的更多注意事项"

#: ../../intro/contributing.txt:620
msgid ""
"Before you get too into writing patches for Django, there's a little more"
" information on contributing that you should probably take a look at:"
msgstr "在你开始为 Django 编写补丁时，这里有些信息，你应该看一看："

#: ../../intro/contributing.txt:623
msgid ""
"You should make sure to read Django's documentation on :doc:`claiming "
"tickets and submitting patches </internals/contributing/writing-code"
"/submitting-patches>`. It covers Trac etiquette, how to claim tickets for"
" yourself, expected coding style for patches, and many other important "
"details."
msgstr ""
"你应该阅读了 Django 的参考文档 :doc:`声明标签和提交补丁 </internals/contributing/writing-code"
"/submitting-patches>`.它涵盖了Trac 规则，如何声称自己的 tickets，补丁的编码风格和其他一些重要信息。"

#: ../../intro/contributing.txt:628
msgid ""
"First time contributors should also read Django's :doc:`documentation for"
" first time contributors</internals/contributing/new-contributors/>`. It "
"has lots of good advice for those of us who are new to helping out with "
"Django."
msgstr ""
"第一次提交补丁额外应该阅读 :doc:`首次贡献者文档</internals/contributing/new-contributors/>`. "
"这里有很多对新手贡献者的建议。"

#: ../../intro/contributing.txt:632
msgid ""
"After those, if you're still hungry for more information about "
"contributing, you can always browse through the rest of :doc:`Django's "
"documentation on contributing</internals/contributing/index>`. It "
"contains a ton of useful information and should be your first source for "
"answering any questions you might have."
msgstr ""
"接下来，如果你想对源码贡献有更深入了解，可以阅读接下来的文档 :doc:`在 Django "
"文档上作出贡献</internals/contributing/index>` . 它包含了大量的有用信息，这里可以解决你可能遇到的所有问题。"

#: ../../intro/contributing.txt:639
msgid "Finding your first real ticket"
msgstr "寻找你的第一个真正的标签"

#: ../../intro/contributing.txt:641
msgid ""
"Once you've looked through some of that information, you'll be ready to "
"go out and find a ticket of your own to write a patch for. Pay special "
"attention to tickets with the \"easy pickings\" criterion. These tickets "
"are often much simpler in nature and are great for first time "
"contributors. Once you're familiar with contributing to Django, you can "
"move on to writing patches for more difficult and complicated tickets."
msgstr "一旦你看过了之前那些信息，你便已经具备了走出困境，为自己编写补丁寻找ticket的能力。对于那些有着“容易获得”标准的ticket要尤其注意。这些ticket实际上常常很简单而且对于第一次撰写补丁的人很有帮助。一旦你熟悉了给Django写补丁，你就可以进一步为更难且更复杂的ticket写补丁。"

#: ../../intro/contributing.txt:648
msgid ""
"If you just want to get started already (and nobody would blame you!), "
"try taking a look at the list of `easy tickets that need patches`__ and "
"the `easy tickets that have patches which need improvement`__. If you're "
"familiar with writing tests, you can also look at the list of `easy "
"tickets that need tests`__. Just remember to follow the guidelines about "
"claiming tickets that were mentioned in the link to Django's "
"documentation on :doc:`claiming tickets and submitting patches "
"</internals/contributing/writing-code/submitting-patches>`."
msgstr ""
"如果你只是想要简单的了解 (没人会因此责备你!), 那么你可以尝试着查看这个`easy tickets that need patches`__ "
"和 `easy tickets that have patches which need improvement`__. "
"如果你比较擅长写测试，那么你也可以看看这个 `easy tickets that need tests`__. "
"一定要记得遵循在Django的文档声明标签和递交补丁中提到的关于声明标签的指导规则. :doc:`声明标签和提交补丁 "
"</internals/contributing/writing-code/submitting-patches>`."

#: ../../intro/contributing.txt:662 ../../intro/tutorial05.txt:685
#: ../../intro/tutorial07.txt:415
msgid "What's next?"
msgstr "接下来要做什么？"

#: ../../intro/contributing.txt:664
msgid ""
"After a ticket has a patch, it needs to be reviewed by a second set of "
"eyes. After uploading a patch or submitting a pull request, be sure to "
"update the ticket metadata by setting the flags on the ticket to say "
"\"has patch\", \"doesn't need tests\", etc, so others can find it for "
"review. Contributing doesn't necessarily always mean writing a patch from"
" scratch. Reviewing existing patches is also a very helpful contribution."
" See :doc:`/internals/contributing/triaging-tickets` for details."
msgstr ""
"一旦一个标签有了补丁, 那么它就需要其他人来重审. 上传了一个补丁或递交了一个 pull request 之后, "
"一定记得更新标签的元数据，比如设置标签的标志状态为 \"has patch\", \"doesn't need tests\", etc, "
"只有这样，其他人才能找到并重审这个标签。从零开始写补丁并不是做贡献的唯一方式.重审一些已经存在的补丁也是一种非常有用的做贡献方式。查看 "
":doc:`/internals/contributing/triaging-tickets` 了解更多详细"

#: ../../intro/index.txt:3
msgid "Getting started"
msgstr "开始"

#: ../../intro/index.txt:5
msgid ""
"New to Django? Or to Web development in general? Well, you came to the "
"right place: read this material to quickly get up and running."
msgstr ""

#: ../../intro/index.txt:26
msgid ""
"If you're new to Python_, you might want to start by getting an idea of "
"what the language is like. Django is 100% Python, so if you've got "
"minimal comfort with Python you'll probably get a lot more out of Django."
msgstr ""

#: ../../intro/index.txt:30
msgid ""
"If you're new to programming entirely, you might want to start with this "
"`list of Python resources for non-programmers`_"
msgstr ""

#: ../../intro/index.txt:33
msgid ""
"If you already know a few other languages and want to get up to speed "
"with Python quickly, we recommend `Dive Into Python`_. If that's not "
"quite your style, there are many other `books about Python`_."
msgstr ""

#: ../../intro/install.txt:3
msgid "Quick install guide"
msgstr "快速安装指南"

#: ../../intro/install.txt:5
msgid ""
"Before you can use Django, you'll need to get it installed. We have a "
":doc:`complete installation guide </topics/install>` that covers all the "
"possibilities; this guide will guide you to a simple, minimal "
"installation that'll work while you walk through the introduction."
msgstr ""

#: ../../intro/install.txt:11
msgid "Install Python"
msgstr "安装Python"

#: ../../intro/install.txt:13
msgid ""
"Being a Python Web framework, Django requires Python. See :ref:`faq-"
"python-version-support` for details. Python includes a lightweight "
"database called SQLite_ so you won't need to set up a database just yet."
msgstr ""
"作为一个 Python Web框架，Django 需要 Python。更多细节请参见 :ref:`faq-python-version-"
"support`。Python 包含了一个名为 SQLite_ 的轻量级数据库，所以你暂时不必自行设置一个数据库。"

#: ../../intro/install.txt:19
msgid ""
"Get the latest version of Python at https://www.python.org/download/ or "
"with your operating system's package manager."
msgstr "您可从 https://www.python.org/download/ 或者您的操作系统的包管理工具获取最新版 Python。"

#: ../../intro/install.txt:22
msgid "Django on Jython"
msgstr "基于 Jython 的 Django"

#: ../../intro/install.txt:24
msgid ""
"If you use Jython_ (a Python implementation for the Java platform), "
"you'll need to follow a few additional steps. See :doc:`/howto/jython` "
"for details."
msgstr ""
"如果您使用 Jython_ (一个Java平台的Python实现)，您将需要进行一些额外的步骤。更多细节请查看 "
":doc:`/howto/jython` 。"

#: ../../intro/install.txt:29
msgid ""
"You can verify that Python is installed by typing ``python`` from your "
"shell; you should see something like::"
msgstr "你可以在你的shell中输入 ``python`` 来确定你是否安装过Python; 你看到的可能是像这样子的::"

#: ../../intro/install.txt:38
msgid "Set up a database"
msgstr "设置一个数据库"

#: ../../intro/install.txt:40
msgid ""
"This step is only necessary if you'd like to work with a \"large\" "
"database engine like PostgreSQL, MySQL, or Oracle. To install such a "
"database, consult the :ref:`database installation information <database-"
"installation>`."
msgstr ""
"此步骤仅在你打算使用诸如 PostgreSQL, MySQL, 或者 Oracle这些大型数据库引擎时需要. 要安装这样一个数据库, 请参考 "
":ref:`数据库安装信息 <database-installation>`."

#: ../../intro/install.txt:45
msgid "Remove any old versions of Django"
msgstr "移除任何老版本的Django"

#: ../../intro/install.txt:47
msgid ""
"If you are upgrading your installation of Django from a previous version,"
" you will need to :ref:`uninstall the old Django version before "
"installing the new version <removing-old-versions-of-django>`."
msgstr ""
"如果你打算从前一版本的Django升级，, 你将需要 :ref:`在安装新版本前删除旧版本的Django <removing-old-"
"versions-of-django>`."

#: ../../intro/install.txt:52
msgid "Install Django"
msgstr "安装Django"

#: ../../intro/install.txt:54
msgid "You've got three easy options to install Django:"
msgstr "你有三个简单的方法来安装Django:"

#: ../../intro/install.txt:56
msgid ""
"Install a version of Django :doc:`provided by your operating system "
"distribution </misc/distributions>`. This is the quickest option for "
"those who have operating systems that distribute Django."
msgstr ""
"安装 django :doc:`操作系统所提供的发行包 </misc/distributions>` 版本. 对于操作系统提供了 "
"Django安装包 的人来说，这是最快捷的安装方法。"

#: ../../intro/install.txt:60
msgid ""
":ref:`Install an official release <installing-official-release>`. This is"
" the best approach for most users."
msgstr ""
":ref:`安装官方正式发布的版本 <installing-official-release>`. "
"这对于想要安装一个稳定版本而不介意运行一个稍旧版本的Django的用户来说是最好的方式。"

#: ../../intro/install.txt:63
msgid ""
":ref:`Install the latest development version <installing-development-"
"version>`. This option is for enthusiasts who want the latest-and-"
"greatest features and aren't afraid of running brand new code. You might "
"encounter new bugs in the development version, but reporting them helps "
"the development of Django. Also, releases of third-party packages are "
"less likely to be compatible with the development version than with the "
"latest stable release."
msgstr ""
":ref:`安装最新开发版 <installing-development-version>`. "
"这个选择是针对那些想要最新和最好的特性的爱好者们，并不怕运行全新代码. 你在开发版中可能会遇到新的错误BUG, 但可以报告给社区团队帮助 "
"Django开发. 此外, 第三方发行的软件包也可能不与开发版进行兼容。"

#: ../../intro/install.txt:71
msgid ""
"Always refer to the documentation that corresponds to the version of "
"Django you're using!"
msgstr "请始终参考与你所使用的版本对应的 Django文档！"

#: ../../intro/install.txt:74
msgid ""
"If you do either of the first two steps, keep an eye out for parts of the"
" documentation marked **new in development version**. That phrase flags "
"features that are only available in development versions of Django, and "
"they likely won't work with an official release."
msgstr ""
"如果采用了前两种方式进行安装, 你需要注意在文档中标明  **在开发版中新增**. 这个标记表明这个特性仅适用开发版 Django, "
"并且他们可能不会在官方发布的稳定版中工作。"

#: ../../intro/install.txt:81
msgid "Verifying"
msgstr "验证"

#: ../../intro/install.txt:83
msgid ""
"To verify that Django can be seen by Python, type ``python`` from your "
"shell. Then at the Python prompt, try to import Django:"
msgstr ""
"若要验证 Django可以被 Python 识别, 可以在shell中输入 ``python`` . 然后在 Python 提示符下，尝试导入 "
"Django：:"

#: ../../intro/install.txt:92
msgid "You may have another version of Django installed."
msgstr "当然了，你也可能安装的是其它版本的 Django。"

#: ../../intro/install.txt:95
msgid "That's it!"
msgstr "就是这个！"

#: ../../intro/install.txt:97
msgid ""
"That's it -- you can now :doc:`move onto the tutorial "
"</intro/tutorial01>`."
msgstr ""

#: ../../intro/overview.txt:3
msgid "Django at a glance"
msgstr "初识 Django"

#: ../../intro/overview.txt:5
msgid ""
"Because Django was developed in a fast-paced newsroom environment, it was"
" designed to make common Web-development tasks fast and easy. Here's an "
"informal overview of how to write a database-driven Web app with Django."
msgstr ""
"Django 最初被设计用于具有快速开发需求的新闻类站点，目的是要实现简单快捷的网站开发。以下内容简要介绍了如何使用 Django "
"实现一个数据库驱动的 Web 应用。"

#: ../../intro/overview.txt:9
msgid ""
"The goal of this document is to give you enough technical specifics to "
"understand how Django works, but this isn't intended to be a tutorial or "
"reference -- but we've got both! When you're ready to start a project, "
"you can :doc:`start with the tutorial </intro/tutorial01>` or :doc:`dive "
"right into more detailed documentation </topics/index>`."
msgstr ""
"为了让您充分理解 Django "
"的工作原理，这份文档为您详细描述了相关的技术细节，不过这并不是一份入门教程或者是参考文档（我们当然也为您准备了这些）。如果您想要马上开始一个项目，可以从"
" :doc:`实例教程 </intro/tutorial01>` 开始入手，或者直接开始阅读详细的 :doc:`参考文档 "
"</topics/index>` "

#: ../../intro/overview.txt:16
msgid "Design your model"
msgstr "设计模型"

#: ../../intro/overview.txt:18
msgid ""
"Although you can use Django without a database, it comes with an `object-"
"relational mapper`_ in which you describe your database layout in Python "
"code."
msgstr "Django 无需数据库就可以使用，它提供了 `对象关系映射器`_ 通过此技术，你可以使用 Python 代码来描述数据库结构。"

#: ../../intro/overview.txt:24
msgid ""
"The :doc:`data-model syntax </topics/db/models>` offers many rich ways of"
" representing your models -- so far, it's been solving many years' worth "
"of database-schema problems. Here's a quick example:"
msgstr ""
"你可以使用强大的 :doc:`数据-模型语句</topics/db/models>` "
"来描述你的数据模型，这解决了数年以来在数据库模式中的难题。以下是一个简明的例子："

#: ../../intro/overview.txt:49
msgid "Install it"
msgstr "应用数据模型"

#: ../../intro/overview.txt:51
msgid ""
"Next, run the Django command-line utility to create the database tables "
"automatically:"
msgstr "然后，运行 Django 命令行工具来创建数据库表："

#: ../../intro/overview.txt:58
msgid ""
"The :djadmin:`migrate` command looks at all your available models and "
"creates tables in your database for whichever tables don't already exist,"
" as well as optionally providing :doc:`much richer schema control "
"</topics/migrations>`."
msgstr ""
"这个 :djadmin:`migrate` 命令查找你所有可用的模型并将在数据库中创建那些不存在的表，还可提供了可选的 "
":doc:`丰富schema控制</topics/migrations>`. "

#: ../../intro/overview.txt:63
msgid "Enjoy the free API"
msgstr "享用便捷的API"

#: ../../intro/overview.txt:65
msgid ""
"With that, you've got a free, and rich, :doc:`Python API "
"</topics/db/queries>` to access your data. The API is created on the fly,"
" no code generation necessary:"
msgstr ""
"接下来，你就可以使用一套便捷而丰富的 :doc:`Python API </topics/db/queries>`  用于访问你的数据。这些 "
"API 是即时创建的，而不用显式的生成代码:"

#: ../../intro/overview.txt:141
msgid ""
"A dynamic admin interface: it's not just scaffolding -- it's the whole "
"house"
msgstr "一个动态管理接口：并非徒有其表"

#: ../../intro/overview.txt:143
msgid ""
"Once your models are defined, Django can automatically create a "
"professional, production ready :doc:`administrative interface "
"</ref/contrib/admin/index>` -- a website that lets authenticated users "
"add, change and delete objects. It's as easy as registering your model in"
" the admin site:"
msgstr ""
"当你的模型完成定义，Django 就会自动生成一个专业的生产级 :doc:`管理接口</ref/contrib/admin/index>`  "
"——一个可以认证用户添加、更改和删除对象的 Web 站点。你只需简单的在 admin 站点上注册你的模型即可："

#: ../../intro/overview.txt:168
msgid ""
"The philosophy here is that your site is edited by a staff, or a client, "
"or maybe just you -- and you don't want to have to deal with creating "
"backend interfaces just to manage content."
msgstr "这样设计所遵循的理念是，站点编辑人员可以是你的员工、你的客户、或者就是你自己——而你大概不会乐意去废半天劲创建一个只有内容管理功能的后台管理界面。"

#: ../../intro/overview.txt:172
msgid ""
"One typical workflow in creating Django apps is to create models and get "
"the admin sites up and running as fast as possible, so your staff (or "
"clients) can start populating data. Then, develop the way data is "
"presented to the public."
msgstr ""
"创建 Django "
"应用的典型流程是，先建立数据模型，然后搭建管理站点，之后你的员工(或者客户)就可以向网站里填充数据了。后面我们会谈到如何展示这些数据。"

#: ../../intro/overview.txt:177
msgid "Design your URLs"
msgstr "规划 URLs"

#: ../../intro/overview.txt:179
msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality Web "
"application. Django encourages beautiful URL design and doesn't put any "
"cruft in URLs, like ``.php`` or ``.asp``."
msgstr ""
"简洁优雅的 URL 规划对于一个高质量 Web 应用来说至关重要。Django 推崇优美的 URL 设计，所以不要把诸如 ``.php`` 和  "
"``.asp``  之类的冗余的后缀放到 URL 里。"

#: ../../intro/overview.txt:183
msgid ""
"To design URLs for an app, you create a Python module called a "
":doc:`URLconf </topics/http/urls>`. A table of contents for your app, it "
"contains a simple mapping between URL patterns and Python callback "
"functions. URLconfs also serve to decouple URLs from Python code."
msgstr ""
"为了设计你自己的 :doc:`URLconf </topics/http/urls>` ，你需要创建一个叫做 URLconf 的 Python "
"模块。这是网站的目录，它包含了一张 URL 和 Python 回调函数之间的映射表。URLconf 也有利于将 Python 代码与 URL "
"进行解耦（译注：使各个模块分离，独立）。"

#: ../../intro/overview.txt:188
msgid ""
"Here's what a URLconf might look like for the ``Reporter``/``Article`` "
"example above:"
msgstr "下面这个 URLconf 适用于前面 ``Reporter``/``Article``  的例子："

#: ../../intro/overview.txt:204
msgid ""
"The code above maps URLs, as simple `regular expressions`_, to the "
"location of Python callback functions (\"views\"). The regular "
"expressions use parenthesis to \"capture\" values from the URLs. When a "
"user requests a page, Django runs through each pattern, in order, and "
"stops at the first one that matches the requested URL. (If none of them "
"matches, Django calls a special-case 404 view.) This is blazingly fast, "
"because the regular expressions are compiled at load time."
msgstr ""
"上面的代码将 URL 的 `正则表达式`_ 映射到 (\"views\") 里的回调函数。正则表达式通过括号来提取 URL "
"中的参数值。当一个用户请求页面时，Django 会遍历这些匹配模式，直至请求的 URL 被成功匹配。(如果 URL 无法匹配，Django "
"会返回一个404视图。)这个过程会在瞬间完成，因为这些正则表达式在启动时会被自动编译。"

#: ../../intro/overview.txt:214
msgid ""
"Once one of the regexes matches, Django imports and calls the given view,"
" which is a simple Python function. Each view gets passed a request "
"object -- which contains request metadata -- and the values captured in "
"the regex."
msgstr ""
"一旦正则表达式匹配成功，Django 会导入并调用指定的视图——一个简单地 Python "
"函数。每个视图都会接收到一个请求（requeset）对象——其中包含了请求元数据——同时还有正则表达式匹配到的那些值。"

#: ../../intro/overview.txt:218
msgid ""
"For example, if a user requested the URL \"/articles/2005/05/39323/\", "
"Django would call the function ``news.views.article_detail(request, "
"'2005', '05', '39323')``."
msgstr ""
"比如，如果用户请求了 \"/articles/2005/05/39323/\" 这样的 URL，Django "
"就会这样调用函数：``news.views.article_detail(request, '2005', '05', '39323')`` ."

#: ../../intro/overview.txt:223
msgid "Write your views"
msgstr "编写视图"

#: ../../intro/overview.txt:225
msgid ""
"Each view is responsible for doing one of two things: Returning an "
":class:`~django.http.HttpResponse` object containing the content for the "
"requested page, or raising an exception such as "
":class:`~django.http.Http404`. The rest is up to you."
msgstr ""
"视图函数的执行结果只可能有两种：返回一个包含请求页面元素的 :class:`~django.http.HttpResponse`  "
"对象，或者是抛出 :class:`~django.http.Http404`  这类异常。至于执行过程中的其他的动作则由你决定。"

#: ../../intro/overview.txt:230
msgid ""
"Generally, a view retrieves data according to the parameters, loads a "
"template and renders the template with the retrieved data. Here's an "
"example view for ``year_archive`` from above:"
msgstr ""
"通常来说，一个视图的工作就是：从参数获取数据，装载一个模板，然后将根据获取的数据对模板进行渲染。下面是一个 ``year_archive`` "
"的视图样例："

#: ../../intro/overview.txt:246
msgid ""
"This example uses Django's :doc:`template system </topics/templates>`, "
"which has several powerful features but strives to stay simple enough for"
" non-programmers to use."
msgstr ""
"这个例子使用了Django :doc:`模板系统 </topics/templates>` "
"，它有着很多强大的功能，而且使用起来足够简单，即使不是程序员也可轻松使用。"

#: ../../intro/overview.txt:251
msgid "Design your templates"
msgstr "设计模板"

#: ../../intro/overview.txt:253
msgid "The code above loads the ``news/year_archive.html`` template."
msgstr "上面的代码加载了 ``news/year_archive.html`` 模板."

#: ../../intro/overview.txt:255
msgid ""
"Django has a template search path, which allows you to minimize "
"redundancy among templates. In your Django settings, you specify a list "
"of directories to check for templates with :setting:`DIRS <TEMPLATES-"
"DIRS>`. If a template doesn't exist in the first directory, it checks the"
" second, and so on."
msgstr ""
"Django 允许设置搜索模板路径，这样可以最小化模板之间的冗余。在Django设置中，你可以通过 :setting:`DIRS "
"<TEMPLATES-DIRS>`  参数指定一个路径列表用于检索模板。如果第一个路径中不包含任何模板，就继续检查第二个，以此类推。"

#: ../../intro/overview.txt:260
msgid ""
"Let's say the ``news/year_archive.html`` template was found. Here's what "
"that might look like:"
msgstr "让我们假设 ``news/year_archive.html`` 模板已经找到. 它看起来可能是下面这个样子："

#: ../../intro/overview.txt:280
msgid ""
"Variables are surrounded by double-curly braces. ``{{ article.headline "
"}}`` means \"Output the value of the article's headline attribute.\" But "
"dots aren't used only for attribute lookup. They also can do dictionary-"
"key lookup, index lookup and function calls."
msgstr ""
"我们看到变量都被双大括号括起来了。 ``{{ article.headline }}``  的意思是“输出 article 的 headline "
"属性值”。这个“点”还有更多的用途，比如查找字典键值、查找索引和函数调用。"

#: ../../intro/overview.txt:285
msgid ""
"Note ``{{ article.pub_date|date:\"F j, Y\" }}`` uses a Unix-style "
"\"pipe\" (the \"|\" character). This is called a template filter, and "
"it's a way to filter the value of a variable. In this case, the date "
"filter formats a Python datetime object in the given format (as found in "
"PHP's date function)."
msgstr ""
"我们注意到 ``{{ article.pub_date|date:\"F j, Y\" }}``  使用了 Unix "
"风格的“管道符”(“|”字符)。这是一个模板过滤器，用于过滤变量值。在这里过滤器将一个 Python datetime 对象转化为指定的格式(就像"
" PHP 中的日期函数那样)。"

#: ../../intro/overview.txt:290
msgid ""
"You can chain together as many filters as you'd like. You can write "
":ref:`custom template filters <howto-writing-custom-template-filters>`. "
"You can write :doc:`custom template tags </howto/custom-template-tags>`, "
"which run custom Python code behind the scenes."
msgstr ""
"你可以将多个过滤器连在一起使用。你还可以使用你 :ref:`自定义的模板过滤器 <howto-writing-custom-template-"
"filters>` 。你甚至可以自己编写 :doc:`自定义的模板标签 </howto/custom-template-tags>` ，相关的 "
"Python 代码会在使用标签时在后台运行。"

#: ../../intro/overview.txt:295
#, python-format
msgid ""
"Finally, Django uses the concept of \"template inheritance\". That's what"
" the ``{% extends \"base.html\" %}`` does. It means \"First load the "
"template called 'base', which has defined a bunch of blocks, and fill the"
" blocks with the following blocks.\" In short, that lets you dramatically"
" cut down on redundancy in templates: each template has to define only "
"what's unique to that template."
msgstr ""
"Django 使用了 ''模板继承'' 的概念。这就是 ``{% extends \"base.html\" %}`` "
"的作用。它的含义是''先加载名为 base "
"的模板，并且用下面的标记块对模板中定义的标记块进行填充''。简而言之，模板继承可以使模板间的冗余内容最小化：每个模板只需包含与其他文档有区别的内容。"

#: ../../intro/overview.txt:301
msgid ""
"Here's what the \"base.html\" template, including the use of :doc:`static"
" files </howto/static-files/index>`, might look like:"
msgstr "下面是 base.html 可能的样子，它使用了 :doc:`静态文件 </howto/static-files/index>` ："

#: ../../intro/overview.txt:318
msgid ""
"Simplistically, it defines the look-and-feel of the site (with the site's"
" logo), and provides \"holes\" for child templates to fill. This makes a "
"site redesign as easy as changing a single file -- the base template."
msgstr ""
"简而言之，它定义了这个网站的外观(还有网站的 "
"logo)，并且给子模板们挖好了可以填的坑。这也让网站的改版变得简单无比——你只需更改这个根模板文件即可。"

#: ../../intro/overview.txt:322
msgid ""
"It also lets you create multiple versions of a site, with different base "
"templates, while reusing child templates. Django's creators have used "
"this technique to create strikingly different mobile versions of sites --"
" simply by creating a new base template."
msgstr ""
"简而言之，它定义了这个网站的外观（还有网站的 "
"logo），并且给子模板们挖好了可以填的坑。这也让网站的改版变得简单无比——你只需更改这个基础模板文件即可。"

#: ../../intro/overview.txt:327
msgid ""
"Note that you don't have to use Django's template system if you prefer "
"another system. While Django's template system is particularly well-"
"integrated with Django's model layer, nothing forces you to use it. For "
"that matter, you don't have to use Django's database API, either. You can"
" use another database abstraction layer, you can read XML files, you can "
"read files off disk, or anything you want. Each piece of Django -- "
"models, views, templates -- is decoupled from the next."
msgstr ""
"注意，你并不是非得使用 Django 的模板系统，你可以使用其他你喜欢的模板系统。尽管 Django "
"的模板系统与其模型层能够集成得很好，但这不意味着你必须使用它。同样，你可以不使用 Django 的数据库 "
"API。你可以用其他的数据库抽象层，像是直接读取 XML 文件，亦或直接读取磁盘文件，你可以使用任何方式。Django "
"的任何组成——模型、视图和模板——都是独立的。"

#: ../../intro/overview.txt:336
msgid "This is just the surface"
msgstr "这仅是基本入门知识"

#: ../../intro/overview.txt:338
msgid ""
"This has been only a quick overview of Django's functionality. Some more "
"useful features:"
msgstr "以上只是 Django 的功能性概述。Django 还有更多实用的特性："

#: ../../intro/overview.txt:341
msgid ""
"A :doc:`caching framework </topics/cache>` that integrates with memcached"
" or other backends."
msgstr ":doc:`缓存框架 </topics/cache>`  可以与 memcached 或其他后端集成。"

#: ../../intro/overview.txt:344
msgid ""
"A :doc:`syndication framework </ref/contrib/syndication>` that makes "
"creating RSS and Atom feeds as easy as writing a small Python class."
msgstr ""
":doc:`聚合器框架 </ref/contrib/syndication>`  可以通过简单编写一个 Python 类来推送 RRS 和 "
"Atom。"

#: ../../intro/overview.txt:347
msgid ""
"More sexy automatically-generated admin features -- this overview barely "
"scratched the surface."
msgstr "更多令人心动的自动化管理功能：概述里面仅仅浅尝辄止。"

#: ../../intro/overview.txt:350
msgid ""
"The next obvious steps are for you to `download Django`_, read :doc:`the "
"tutorial </intro/tutorial01>` and join `the community`_. Thanks for your "
"interest!"
msgstr ""
"接下来您可以 `下载 Django`_ ，阅读 :doc:`实例教程</intro/tutorial01>` ，然后加入我们的 `社区`_ "
"！感谢您的关注！"

#: ../../intro/reusable-apps.txt:3
msgid "Advanced tutorial: How to write reusable apps"
msgstr ""

#: ../../intro/reusable-apps.txt:5
msgid ""
"This advanced tutorial begins where :doc:`Tutorial 7 </intro/tutorial07>`"
" left off. We'll be turning our Web-poll into a standalone Python package"
" you can reuse in new projects and share with other people."
msgstr ""

#: ../../intro/reusable-apps.txt:9
msgid ""
"If you haven't recently completed Tutorials 1–7, we encourage you to "
"review these so that your example project matches the one described "
"below."
msgstr ""

#: ../../intro/reusable-apps.txt:13
msgid "Reusability matters"
msgstr ""

#: ../../intro/reusable-apps.txt:15
msgid ""
"It's a lot of work to design, build, test and maintain a web application."
" Many Python and Django projects share common problems. Wouldn't it be "
"great if we could save some of this repeated work?"
msgstr ""

#: ../../intro/reusable-apps.txt:19
msgid ""
"Reusability is the way of life in Python. `The Python Package Index "
"(PyPI) <https://pypi.python.org/pypi>`_ has a vast range of packages you "
"can use in your own Python programs. Check out `Django Packages "
"<https://www.djangopackages.com>`_ for existing reusable apps you could "
"incorporate in your project. Django itself is also just a Python package."
" This means that you can take existing Python packages or Django apps and"
" compose them into your own web project. You only need to write the parts"
" that make your project unique."
msgstr ""

#: ../../intro/reusable-apps.txt:28
msgid ""
"Let's say you were starting a new project that needed a polls app like "
"the one we've been working on. How do you make this app reusable? "
"Luckily, you're well on the way already. In :doc:`Tutorial 3 "
"</intro/tutorial03>`, we saw how we could decouple polls from the "
"project-level URLconf using an ``include``. In this tutorial, we'll take "
"further steps to make the app easy to use in new projects and ready to "
"publish for others to install and use."
msgstr ""

#: ../../intro/reusable-apps.txt:35
msgid "Package? App?"
msgstr ""

#: ../../intro/reusable-apps.txt:37
msgid ""
"A Python `package "
"<https://docs.python.org/tutorial/modules.html#packages>`_ provides a way"
" of grouping related Python code for easy reuse. A package contains one "
"or more files of Python code (also known as \"modules\")."
msgstr ""

#: ../../intro/reusable-apps.txt:41
msgid ""
"A package can be imported with ``import foo.bar`` or ``from foo import "
"bar``. For a directory (like ``polls``) to form a package, it must "
"contain a special file ``__init__.py``, even if this file is empty."
msgstr ""

#: ../../intro/reusable-apps.txt:45
msgid ""
"A Django *application* is just a Python package that is specifically "
"intended for use in a Django project. An application may use common "
"Django conventions, such as having ``models``, ``tests``, ``urls``, and "
"``views`` submodules."
msgstr ""

#: ../../intro/reusable-apps.txt:50
msgid ""
"Later on we use the term *packaging* to describe the process of making a "
"Python package easy for others to install. It can be a little confusing, "
"we know."
msgstr ""

#: ../../intro/reusable-apps.txt:55
msgid "Your project and your reusable app"
msgstr ""

#: ../../intro/reusable-apps.txt:57
msgid "After the previous tutorials, our project should look like this::"
msgstr ""

#: ../../intro/reusable-apps.txt:90
msgid ""
"You created ``mysite/templates`` in :doc:`Tutorial 7 "
"</intro/tutorial07>`, and ``polls/templates`` in :doc:`Tutorial 3 "
"</intro/tutorial03>`. Now perhaps it is clearer why we chose to have "
"separate template directories for the project and application: everything"
" that is part of the polls application is in ``polls``. It makes the "
"application self-contained and easier to drop into a new project."
msgstr ""

#: ../../intro/reusable-apps.txt:97
msgid ""
"The ``polls`` directory could now be copied into a new Django project and"
" immediately reused. It's not quite ready to be published though. For "
"that, we need to package the app to make it easy for others to install."
msgstr ""

#: ../../intro/reusable-apps.txt:104
msgid "Installing some prerequisites"
msgstr ""

#: ../../intro/reusable-apps.txt:106
msgid ""
"The current state of Python packaging is a bit muddled with various "
"tools. For this tutorial, we're going to use setuptools_ to build our "
"package. It's the recommended packaging tool (merged with the "
"``distribute`` fork). We'll also be using `pip`_ to install and uninstall"
" it. You should install these two packages now. If you need help, you can"
" refer to :ref:`how to install Django with pip<installing-official-"
"release>`. You can install ``setuptools`` the same way."
msgstr ""

#: ../../intro/reusable-apps.txt:118
msgid "Packaging your app"
msgstr ""

#: ../../intro/reusable-apps.txt:120
msgid ""
"Python *packaging* refers to preparing your app in a specific format that"
" can be easily installed and used. Django itself is packaged very much "
"like this. For a small app like polls, this process isn't too difficult."
msgstr ""

#: ../../intro/reusable-apps.txt:124
msgid ""
"First, create a parent directory for ``polls``, outside of your Django "
"project. Call this directory ``django-polls``."
msgstr ""

#: ../../intro/reusable-apps.txt:127
msgid "Choosing a name for your app"
msgstr ""

#: ../../intro/reusable-apps.txt:129
msgid ""
"When choosing a name for your package, check resources like PyPI to avoid"
" naming conflicts with existing packages. It's often useful to prepend "
"``django-`` to your module name when creating a package to distribute. "
"This helps others looking for Django apps identify your app as Django "
"specific."
msgstr ""

#: ../../intro/reusable-apps.txt:135
msgid ""
"Application labels (that is, the final part of the dotted path to "
"application packages) *must* be unique in :setting:`INSTALLED_APPS`. "
"Avoid using the same label as any of the Django :doc:`contrib packages "
"</ref/contrib/index>`, for example ``auth``, ``admin``, or ``messages``."
msgstr ""

#: ../../intro/reusable-apps.txt:141
msgid "Move the ``polls`` directory into the ``django-polls`` directory."
msgstr ""

#: ../../intro/reusable-apps.txt:143
msgid "Create a file ``django-polls/README.rst`` with the following contents:"
msgstr ""

#: ../../intro/reusable-apps.txt:178
msgid ""
"Create a ``django-polls/LICENSE`` file. Choosing a license is beyond the "
"scope of this tutorial, but suffice it to say that code released publicly"
" without a license is *useless*. Django and many Django-compatible apps "
"are distributed under the BSD license; however, you're free to pick your "
"own license. Just be aware that your licensing choice will affect who is "
"able to use your code."
msgstr ""

#: ../../intro/reusable-apps.txt:185
msgid ""
"Next we'll create a ``setup.py`` file which provides details about how to"
" build and install the app.  A full explanation of this file is beyond "
"the scope of this tutorial, but the `setuptools docs "
"<https://pythonhosted.org/setuptools/setuptools.html>`_ have a good "
"explanation. Create a file ``django-polls/setup.py`` with the following "
"contents:"
msgstr ""

#: ../../intro/reusable-apps.txt:232
msgid ""
"Only Python modules and packages are included in the package by default. "
"To include additional files, we'll need to create a ``MANIFEST.in`` file."
" The setuptools docs referred to in the previous step discuss this file "
"in more details. To include the templates, the ``README.rst`` and our "
"``LICENSE`` file, create a file ``django-polls/MANIFEST.in`` with the "
"following contents:"
msgstr ""

#: ../../intro/reusable-apps.txt:247
msgid ""
"It's optional, but recommended, to include detailed documentation with "
"your app. Create an empty directory ``django-polls/docs`` for future "
"documentation. Add an additional line to ``django-polls/MANIFEST.in``::"
msgstr ""

#: ../../intro/reusable-apps.txt:253
msgid ""
"Note that the ``docs`` directory won't be included in your package unless"
" you add some files to it. Many Django apps also provide their "
"documentation online through sites like `readthedocs.org "
"<https://readthedocs.org>`_."
msgstr ""

#: ../../intro/reusable-apps.txt:257
msgid ""
"Try building your package with ``python setup.py sdist`` (run from inside"
" ``django-polls``). This creates a directory called ``dist`` and builds "
"your new package, ``django-polls-0.1.tar.gz``."
msgstr ""

#: ../../intro/reusable-apps.txt:261
msgid ""
"For more information on packaging, see Python's `Tutorial on Packaging "
"and Distributing Projects "
"<https://packaging.python.org/en/latest/distributing.html>`_."
msgstr ""

#: ../../intro/reusable-apps.txt:265
msgid "Using your own package"
msgstr ""

#: ../../intro/reusable-apps.txt:267
msgid ""
"Since we moved the ``polls`` directory out of the project, it's no longer"
" working. We'll now fix this by installing our new ``django-polls`` "
"package."
msgstr ""

#: ../../intro/reusable-apps.txt:270
msgid "Installing as a user library"
msgstr ""

#: ../../intro/reusable-apps.txt:272
msgid ""
"The following steps install ``django-polls`` as a user library. Per-user "
"installs have a lot of advantages over installing the package system-"
"wide, such as being usable on systems where you don't have administrator "
"access as well as preventing the package from affecting system services "
"and other users of the machine."
msgstr ""

#: ../../intro/reusable-apps.txt:278
msgid ""
"Note that per-user installations can still affect the behavior of system "
"tools that run as that user, so ``virtualenv`` is a more robust solution "
"(see below)."
msgstr ""

#: ../../intro/reusable-apps.txt:282
msgid ""
"To install the package, use pip (you already :ref:`installed it "
"<installing-reusable-apps-prerequisites>`, right?)::"
msgstr ""

#: ../../intro/reusable-apps.txt:287
msgid ""
"With luck, your Django project should now work correctly again. Run the "
"server again to confirm this."
msgstr ""

#: ../../intro/reusable-apps.txt:290
msgid "To uninstall the package, use pip::"
msgstr ""

#: ../../intro/reusable-apps.txt:297
msgid "Publishing your app"
msgstr ""

#: ../../intro/reusable-apps.txt:299
msgid ""
"Now that we've packaged and tested ``django-polls``, it's ready to share "
"with the world! If this wasn't just an example, you could now:"
msgstr ""

#: ../../intro/reusable-apps.txt:302
msgid "Email the package to a friend."
msgstr ""

#: ../../intro/reusable-apps.txt:304
msgid "Upload the package on your website."
msgstr ""

#: ../../intro/reusable-apps.txt:306
msgid ""
"Post the package on a public repository, such as `the Python Package "
"Index (PyPI)`_. `packaging.python.org <https://packaging.python.org>`_ "
"has `a good tutorial "
"<https://packaging.python.org/en/latest/distributing.html#uploading-your-"
"project-to-pypi>`_ for doing this."
msgstr ""

#: ../../intro/reusable-apps.txt:312
msgid "Installing Python packages with virtualenv"
msgstr ""

#: ../../intro/reusable-apps.txt:314
msgid ""
"Earlier, we installed the polls app as a user library. This has some "
"disadvantages:"
msgstr ""

#: ../../intro/reusable-apps.txt:317
msgid ""
"Modifying the user libraries can affect other Python software on your "
"system."
msgstr ""

#: ../../intro/reusable-apps.txt:319
msgid ""
"You won't be able to run multiple versions of this package (or others "
"with the same name)."
msgstr ""

#: ../../intro/reusable-apps.txt:322
msgid ""
"Typically, these situations only arise once you're maintaining several "
"Django projects. When they do, the best solution is to use `virtualenv "
"<http://www.virtualenv.org/>`_. This tool allows you to maintain multiple"
" isolated Python environments, each with its own copy of the libraries "
"and package namespace."
msgstr ""

#: ../../intro/tutorial01.txt:3
msgid "Writing your first Django app, part 1"
msgstr "编写你的第一个Django应用，第1部分"

#: ../../intro/tutorial01.txt:5
msgid "Let's learn by example."
msgstr "让我们通过示例来学习。"

#: ../../intro/tutorial01.txt:7
msgid ""
"Throughout this tutorial, we'll walk you through the creation of a basic "
"poll application."
msgstr "通过这个教程，我们将带着你创建一个基本的投票应用程序。"

#: ../../intro/tutorial01.txt:10
msgid "It'll consist of two parts:"
msgstr "它将由两部分组成："

#: ../../intro/tutorial01.txt:12
msgid "A public site that lets people view polls and vote in them."
msgstr "一个让人们查看和投票的公共站点。"

#: ../../intro/tutorial01.txt:13
msgid "An admin site that lets you add, change, and delete polls."
msgstr "一个让你能添加、改变和删除投票的管理站点。"

#: ../../intro/tutorial01.txt:15
msgid ""
"We'll assume you have :doc:`Django installed </intro/install>` already. "
"You can tell Django is installed and which version by running the "
"following command:"
msgstr ""
"我们假设你已经成功了 :doc:`Django 安装 </intro/install>` 如果你不清楚是否已经安装 Django "
"或不清楚安装的版本，请尝试以下命令:"

#: ../../intro/tutorial01.txt:22
msgid ""
"If Django is installed, you should see the version of your installation. "
"If it isn't, you'll get an error telling \"No module named django\"."
msgstr ""
"如果这行命令输出了一个版本号，证明你已经安装了此版本的 Django；如果你得到的是一个“No module named "
"django”的错误提示，则表示你还未安装。"

#: ../../intro/tutorial01.txt:25
msgid ""
"This tutorial is written for Django |version| and Python 3.4 or later. If"
" the Django version doesn't match, you can refer to the tutorial for your"
" version of Django by using the version switcher at the bottom right "
"corner of this page, or update Django to the newest version. If you are "
"still using Python 2.7, you will need to adjust the code samples "
"slightly, as described in comments."
msgstr ""
"本教程的目标版本是 Django |version| 和 Python 3.4 或更高版本. 如果 Django "
"版本不匹配，你可以通过点击页面右下角的切换版本按钮来转到适合你版本的教程，或者你可以选择将 Django 升级到最新的版本。如果你使用的是 "
"Python 2.7，那么需要对教程中的代码作一些微调，如何调整将会写在代码的注释里。"

#: ../../intro/tutorial01.txt:32
msgid ""
"See :doc:`How to install Django </topics/install>` for advice on how to "
"remove older versions of Django and install a newer one."
msgstr "你可以查看文档 :doc:`如何安装 Django </topics/install>` 来获得关于移除旧版本，安装新版本的流程和建议。"

#: ../../intro/tutorial01.txt:37
msgid ""
"If you're having trouble going through this tutorial, please post a "
"message to |django-users| or drop by `#django on irc.freenode.net "
"<irc://irc.freenode.net/django>`_ to chat with other Django users who "
"might be able to help."
msgstr ""
"如果你在阅读或实践本教程中遇到困难, 请发消息给 |django-users| 或加入 `#django on irc.freenode.net "
"<irc://irc.freenode.net/django>`_ 来和其他的 Django 用户交流，他们也许能帮到你。"

#: ../../intro/tutorial01.txt:43
msgid "Creating a project"
msgstr "创建项目"

#: ../../intro/tutorial01.txt:45
msgid ""
"If this is your first time using Django, you'll have to take care of some"
" initial setup. Namely, you'll need to auto-generate some code that "
"establishes a Django :term:`project` -- a collection of settings for an "
"instance of Django, including database configuration, Django-specific "
"options and application-specific settings."
msgstr ""
"如果这是你第一次使用 Django 的话, 你需要一些初始化设置. 也就是说, 你需要一些自动生成的代码来配置一个 Django "
":term:`project` -- 即一个 Django项目实例需要的设置项集合，包括 Django 配置和应用程序设置。"

#: ../../intro/tutorial01.txt:51
msgid ""
"From the command line, ``cd`` into a directory where you'd like to store "
"your code, then run the following command:"
msgstr "打开命令行，``cd`` 到一个你想放置你代码的目录，然后运行以下命令："

#: ../../intro/tutorial01.txt:58
msgid ""
"This will create a ``mysite`` directory in your current directory. If it "
"didn't work, see :ref:`troubleshooting-django-admin`."
msgstr ""
"这行代码将会在当前目录下创建一个 ``mysite`` 目录. 如果命令失败了, 查看 :ref:`troubleshooting-django-"
"admin`，可能能给你提供帮助。"

#: ../../intro/tutorial01.txt:63
msgid ""
"You'll need to avoid naming projects after built-in Python or Django "
"components. In particular, this means you should avoid using names like "
"``django`` (which will conflict with Django itself) or ``test`` (which "
"conflicts with a built-in Python package)."
msgstr ""
"你得避免使用 Python 或 Django 的内部保留字来命名你的项目。具体地说，你得避免使用像 ``django`` (会和 Django "
"自己产生冲突)或  ``test`` (会合 Python 的内置模块产生冲突)这样的名字。"

#: ../../intro/tutorial01.txt:68
msgid "Where should this code live?"
msgstr "我的代码该放在哪？"

#: ../../intro/tutorial01.txt:70
msgid ""
"If your background is in plain old PHP (with no use of modern "
"frameworks), you're probably used to putting code under the Web server's "
"document root (in a place such as ``/var/www``). With Django, you don't "
"do that. It's not a good idea to put any of this Python code within your "
"Web server's document root, because it risks the possibility that people "
"may be able to view your code over the Web. That's not good for security."
msgstr ""
"如果你曾经是老式 PHP 程序员(没有使用过现代框架)，你可能会习惯于把代码放在 Web 服务器的文档根目录(诸如 "
"``/var/www``)。当使用 Django 时不需要这样做。把所有 Python 代码放在 Web "
"服务器的根目录不是个好主意，因为这样会有风险。比如会提高人们在网站上看到你的代码的可能性。这不利于网站的安全。"

#: ../../intro/tutorial01.txt:77
msgid ""
"Put your code in some directory **outside** of the document root, such as"
" :file:`/home/mycode`."
msgstr "把你的代码放在文档根目录 **以外** 的某些地方吧，比如 `/home/mycode`。"

#: ../../intro/tutorial01.txt:80
msgid "Let's look at what :djadmin:`startproject` created::"
msgstr "让我们看看 :djadmin:`startproject` 创建了些什么::"

#: ../../intro/tutorial01.txt:90
msgid "These files are:"
msgstr "这些目录和文件的用处是："

#: ../../intro/tutorial01.txt:92
msgid ""
"The outer :file:`mysite/` root directory is just a container for your "
"project. Its name doesn't matter to Django; you can rename it to anything"
" you like."
msgstr "最外层的:file: `mysite/` 根目录只是你项目的容器， Django 不关心它的名字，你可以将它重命名为任何你喜欢的名字。"

#: ../../intro/tutorial01.txt:96
msgid ""
":file:`manage.py`: A command-line utility that lets you interact with "
"this Django project in various ways. You can read all the details about "
":file:`manage.py` in :doc:`/ref/django-admin`."
msgstr ""
":file:`manage.py`: 一个让你用各种方式管理 Django 项目的命令行工具。. 你可以阅读 :file:`manage.py` "
"in :doc:`/ref/django-admin` 获取关于 manage.py 的更多细节。"

#: ../../intro/tutorial01.txt:100
msgid ""
"The inner :file:`mysite/` directory is the actual Python package for your"
" project. Its name is the Python package name you'll need to use to "
"import anything inside it (e.g. ``mysite.urls``)."
msgstr ""
"里面一层的 :file:`mysite/`  目录包含你的项目 它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 "
"Python 包名。 (e.g. ``mysite.urls``)."

#: ../../intro/tutorial01.txt:104
msgid ""
":file:`mysite/__init__.py`: An empty file that tells Python that this "
"directory should be considered a Python package. (Read `more about "
"packages`_ in the official Python docs if you're a Python beginner.)"
msgstr ""
":file:`mysite/__init__.py`: 一个用于指明此目录是 Python 包的空白文件。 (如果你刚开始学习 "
"Python，请阅读 Python 官方文档中的 `more about packages`_ 部分)"

#: ../../intro/tutorial01.txt:108
msgid ""
":file:`mysite/settings.py`: Settings/configuration for this Django "
"project.  :doc:`/topics/settings` will tell you all about how settings "
"work."
msgstr ""
":file:`mysite/settings.py` : Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 "
":doc:`/topics/settings` 了解细节。"

#: ../../intro/tutorial01.txt:112
msgid ""
":file:`mysite/urls.py`: The URL declarations for this Django project; a "
"\"table of contents\" of your Django-powered site. You can read more "
"about URLs in :doc:`/topics/http/urls`."
msgstr ""
":file:`mysite/urls.py`: Django 项目的 URL 声明，就像你网站的 \"目录\" 阅读 "
":doc:`/topics/http/urls` 文档来获取更多关于 URL 的内容。."

#: ../../intro/tutorial01.txt:116
msgid ""
":file:`mysite/wsgi.py`: An entry-point for WSGI-compatible web servers to"
" serve your project. See :doc:`/howto/deployment/wsgi/index` for more "
"details."
msgstr ""
":file:`mysite/wsgi.py`: 用于你的项目的与WSGI兼容的Web服务器入口. 阅读 "
":doc:`/howto/deployment/wsgi/index` 了解更多细节。"

#: ../../intro/tutorial01.txt:122
msgid "The development server"
msgstr "用于开发的简易服务器"

#: ../../intro/tutorial01.txt:124
msgid ""
"Let's verify your Django project works. Change into the outer "
":file:`mysite` directory, if you haven't already, and run the following "
"commands:"
msgstr ""
"让我们来确认一下你的 Django 项目是否真的创建成功了。如果你的当前目录不是外层的 :file:`mysite` "
"目录的话，请切换到此目录，然后运行下面的命令："

#: ../../intro/tutorial01.txt:131
msgid "You'll see the following output on the command line:"
msgstr "你应该会看到如下输出："

#: ../../intro/tutorial01.txt:148
msgid ""
"Ignore the warning about unapplied database migrations for now; we'll "
"deal with the database shortly."
msgstr "忽略有关未应用现在数据库迁移的警告;稍后我们处理数据库。"

#: ../../intro/tutorial01.txt:151
msgid ""
"You've started the Django development server, a lightweight Web server "
"written purely in Python. We've included this with Django so you can "
"develop things rapidly, without having to deal with configuring a "
"production server -- such as Apache -- until you're ready for production."
msgstr ""
"你刚刚启动的是 Django 自带的用于开发的简易服务器，它是一个用纯 Python 写的轻量级的 Web 服务器。我们将这个服务器内置在 "
"Django 中是为了让你能快速的开发出想要的东西，因为你不需要进行配置生产级别的服务器（比如 "
"Apache）方面的工作，除非你已经准备好投入生产环境了。"

#: ../../intro/tutorial01.txt:156
msgid ""
"Now's a good time to note: **don't** use this server in anything "
"resembling a production environment. It's intended only for use while "
"developing. (We're in the business of making Web frameworks, not Web "
"servers.)"
msgstr ""
"现在是个提醒你的好时机：**千万不要** 将这个服务器用于和生产环境相关的任何地方。这个服务器只是为了开发而设计的。(我们在 Web "
"框架方面是专家，在 Web 服务器方面并不是。)"

#: ../../intro/tutorial01.txt:160
msgid ""
"Now that the server's running, visit http://127.0.0.1:8000/ with your Web"
" browser. You'll see a \"Welcome to Django\" page, in pleasant, light-"
"blue pastel. It worked!"
msgstr ""
"现在这个小服务器已经开始工作了，尝试用你的浏览器访问 "
"\"http://127.0.0.1:8000\"。不出意外的话，你将会看见令人赏心悦目的浅蓝色 \"Django "
"欢迎页\"，这代表你的项目已经创建成功了。"

#: ../../intro/tutorial01.txt:164
msgid "Changing the port"
msgstr "更换端口"

#: ../../intro/tutorial01.txt:166
msgid ""
"By default, the :djadmin:`runserver` command starts the development "
"server on the internal IP at port 8000."
msgstr "默认情况下，:djadmin:`runserver` 命令会将服务器设置为监听本机内部 IP 的 8000 端口。"

#: ../../intro/tutorial01.txt:169
msgid ""
"If you want to change the server's port, pass it as a command-line "
"argument. For instance, this command starts the server on port 8080:"
msgstr "如果你想更换服务器的端口，请使用命令行参数。举个例子，下面的命令会使服务器监听 8080 端口： "

#: ../../intro/tutorial01.txt:177
msgid ""
"If you want to change the server's IP, pass it along with the port. So to"
" listen on all public IPs (useful if you want to show off your work on "
"other computers on your network), use:"
msgstr ""
"如果你想改变监听的 IP 的话，可以将它和端口号写在一起作为参数。所以，监听所有公网 "
"IP(在你想将你的工作通过你的网络共享给其他人时尤其有用)的命令是： "

#: ../../intro/tutorial01.txt:185
msgid ""
"Full docs for the development server can be found in the "
":djadmin:`runserver` reference."
msgstr "关于这个简易服务器的完整信息可以在 :djadmin:`runserver` 文档中找到。"

#: ../../intro/tutorial01.txt:188
msgid "Automatic reloading of :djadmin:`runserver`"
msgstr "会自动重新加载的服务器 :djadmin:`runserver`"

#: ../../intro/tutorial01.txt:190
msgid ""
"The development server automatically reloads Python code for each request"
" as needed. You don't need to restart the server for code changes to take"
" effect. However, some actions like adding files don't trigger a restart,"
" so you'll have to restart the server in these cases."
msgstr ""
"用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍 Python "
"代码。所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。"

#: ../../intro/tutorial01.txt:196
msgid "Creating the Polls app"
msgstr "创建投票应用"

#: ../../intro/tutorial01.txt:198
msgid ""
"Now that your environment -- a \"project\" -- is set up, you're set to "
"start doing work."
msgstr "现在你的开发环境——这个\"project\" ——已经设置好了，你可以开始工作了。"

#: ../../intro/tutorial01.txt:201
msgid ""
"Each application you write in Django consists of a Python package that "
"follows a certain convention. Django comes with a utility that "
"automatically generates the basic directory structure of an app, so you "
"can focus on writing code rather than creating directories."
msgstr ""
"在 Django 中，每一个应用都是一个 Python 包，并且遵循着一定的约定。Django "
"自带一个工具，可以帮你生成应用的基础目录结构，这样你就能专心的聚焦于写代码，而不是安排目录了。"

#: ../../intro/tutorial01.txt:206
msgid "Projects vs. apps"
msgstr "项目 VS 应用"

#: ../../intro/tutorial01.txt:208
msgid ""
"What's the difference between a project and an app? An app is a Web "
"application that does something -- e.g., a Weblog system, a database of "
"public records or a simple poll app. A project is a collection of "
"configuration and apps for a particular website. A project can contain "
"multiple apps. An app can be in multiple projects."
msgstr ""
"项目和应用有啥区别？应用是一个专门做某件事的网络应用程序 -- "
"比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。"

#: ../../intro/tutorial01.txt:214
msgid ""
"Your apps can live anywhere on your `Python path`_. In this tutorial, "
"we'll create our poll app right next to your :file:`manage.py` file so "
"that it can be imported as its own top-level module, rather than a "
"submodule of ``mysite``."
msgstr ""
"你的应用可以放在  `Python path`_  中的任何目录里。在这个教程中，我们将直接在 :file:`manage.py` "
"所在的目录里创建投票应用，这样它就能够被当做顶级模块被引入，而不是作为 ``mysite`` 的子模块。"

#: ../../intro/tutorial01.txt:218
msgid ""
"To create your app, make sure you're in the same directory as "
":file:`manage.py` and type this command:"
msgstr "请确定你现在处于 :file:`manage.py` 所在的目录下，然后运行这行命令来创建一个应用："

#: ../../intro/tutorial01.txt:225
msgid "That'll create a directory :file:`polls`, which is laid out like this::"
msgstr "这将会创建一个 :file:`polls` 目录，它的目录结构大致如下："

#: ../../intro/tutorial01.txt:237
msgid "This directory structure will house the poll application."
msgstr "这个目录结构包括了投票应用的全部内容。"

#: ../../intro/tutorial01.txt:242
msgid "Write your first view"
msgstr "编写第一个视图"

#: ../../intro/tutorial01.txt:244
msgid ""
"Let's write the first view. Open the file ``polls/views.py`` and put the "
"following Python code in it:"
msgstr "让我们开始编写第一个视图吧。打开 ``polls/views.py`` ，把下面这些 Python 代码输入进去："

#: ../../intro/tutorial01.txt:256
msgid ""
"This is the simplest view possible in Django. To call the view, we need "
"to map it to a URL - and for this we need a URLconf."
msgstr "这是 Django 中最简单的视图。如果想看见效果，我们需要将一个 URL 映射到它——这就是我们需要 URLconf 的原因了。"

#: ../../intro/tutorial01.txt:259
msgid ""
"To create a URLconf in the polls directory, create a file called "
"``urls.py``. Your app directory should now look like::"
msgstr "为了创建 URLconf，请在 polls 目录里新建一个 ``urls.py``  文件。你的应用目录现在看起来应该是这样："

#: ../../intro/tutorial01.txt:273
msgid "In the ``polls/urls.py`` file include the following code:"
msgstr "在 ``polls/urls.py`` 中，输入如下代码："

#: ../../intro/tutorial01.txt:286
msgid ""
"The next step is to point the root URLconf at the ``polls.urls`` module. "
"In ``mysite/urls.py``, add an import for ``django.conf.urls.include`` and"
" insert an :func:`~django.conf.urls.include` in the ``urlpatterns`` list,"
" so you have:"
msgstr ""
"下一步是要在根 URLconf 文件中指定我们创建的 ``polls.urls`` 模块。在 ``mysite/urls.py`` 文件中 "
"``urlpatterns`` 列表里插入一个 :func:`~django.conf.urls.include`， 如下："

#: ../../intro/tutorial01.txt:301
msgid ""
"The :func:`~django.conf.urls.include` function allows referencing other "
"URLconfs. Note that the regular expressions for the "
":func:`~django.conf.urls.include` function doesn't have a ``$`` (end-of-"
"string match character) but rather a trailing slash. Whenever Django "
"encounters :func:`~django.conf.urls.include`, it chops off whatever part "
"of the URL matched up to that point and sends the remaining string to the"
" included URLconf for further processing."
msgstr ""

#: ../../intro/tutorial01.txt:309
msgid ""
"The idea behind :func:`~django.conf.urls.include` is to make it easy to "
"plug-and-play URLs. Since polls are in their own URLconf "
"(``polls/urls.py``), they can be placed under \"/polls/\", or under "
"\"/fun_polls/\", or under \"/content/polls/\", or any other path root, "
"and the app will still work."
msgstr ""
"我们设计 :func:`~django.conf.urls.include`  函数是为了让 URLconf 也能轻松的「即插即用」。因为 "
"polls 应用有他自己的 URLconf( ``polls/urls.py`` )，他们能够被放在 \"/polls/\" 下、 "
"\"/fun_polls/\" 下、 \"/content/polls/\" 下，或者其他任何路径下，这个应用都能够正常工作。"

#: ../../intro/tutorial01.txt:315
msgid "When to use :func:`~django.conf.urls.include()`"
msgstr "什么时候使用 :func:`~django.conf.urls.include()` "

#: ../../intro/tutorial01.txt:317
msgid ""
"You should always use ``include()`` when you include other URL patterns. "
"``admin.site.urls`` is the only exception to this."
msgstr "当包括其它URL模式时你应该总是使用 ``include()`` ， ``admin.site.urls`` 是唯一例外。"

#: ../../intro/tutorial01.txt:320
msgid "Doesn't match what you see?"
msgstr "和你看到的不一样？"

#: ../../intro/tutorial01.txt:322
msgid ""
"If you're seeing ``include(admin.site.urls)`` instead of just "
"``admin.site.urls``, you're probably using a version of Django that "
"doesn't match this tutorial version.  You'll want to either switch to the"
" older tutorial or the newer Django version."
msgstr ""
"如果你看到 ``include(admin.site.urls)`` 而不是仅仅 ``admin.site.urls``, "
"你可能使用了和教程不匹配的 Django 版本。你可以切换到旧版本的教程或者升级 Django。"

#: ../../intro/tutorial01.txt:327
msgid ""
"You have now wired an ``index`` view into the URLconf. Lets verify it's "
"working, run the following command:"
msgstr "你现在把 ``index`` 视图添加进了 URLconf。可以验证是否正常工作，运行下面的命令:"

#: ../../intro/tutorial01.txt:334
msgid ""
"Go to http://localhost:8000/polls/ in your browser, and you should see "
"the text \"*Hello, world. You're at the polls index.*\", which you "
"defined in the ``index`` view."
msgstr ""
"用你的浏览器访问 http://localhost:8000/polls/，你应该能够看见 \"*Hello, world. You're at "
"the polls index.*\" ，这是你在 ``index`` 视图中定义的。"

#: ../../intro/tutorial01.txt:338
msgid ""
"The :func:`~django.conf.urls.url` function is passed four arguments, two "
"required: ``regex`` and ``view``, and two optional: ``kwargs``, and "
"``name``. At this point, it's worth reviewing what these arguments are "
"for."
msgstr ""
" :func:`~django.conf.urls.url` 函数具有四个参数：两个必需的 ``regex`` 和   ``view`` "
"，以及两个可选的 ``kwargs`` 和 ``name`` 。 到这里，就可以研究下这些参数的含义了："

#: ../../intro/tutorial01.txt:343
msgid ":func:`~django.conf.urls.url` argument: regex"
msgstr ":func:`~django.conf.urls.url` 参数: regex"

#: ../../intro/tutorial01.txt:345
msgid ""
"The term \"regex\" is a commonly used short form meaning \"regular "
"expression\", which is a syntax for matching patterns in strings, or in "
"this case, url patterns. Django starts at the first regular expression "
"and makes its way down the list,  comparing the requested URL against "
"each regular expression until it finds one that matches."
msgstr ""
"术语 \"regex\" 通常作为\"正则表达式 regular expression\" "
"的简写出现，它是一种用于匹配字符串的语法，我们用它来编写 URL 模式。Django "
"从第一个开始，按顺序依次使用列表里的正则表达式来尝试匹配请求的 URL，直到遇到一个可以匹配的表达式。"

#: ../../intro/tutorial01.txt:351
msgid ""
"Note that these regular expressions do not search GET and POST "
"parameters, or the domain name. For example, in a request to "
"``https://www.example.com/myapp/``, the URLconf will look for ``myapp/``."
" In a request to ``https://www.example.com/myapp/?page=3``, the URLconf "
"will also look for ``myapp/``."
msgstr ""
"请注意这些正则式并不尝试匹配 GET 或 POST 的参数。也不匹配域名部分。举例说明，在用户请求 "
"``https://www.example.com/myapp/`` 时,URLconf 将会尝试匹配  ``myapp/`` 。在请求  "
"``https://www.example.com/myapp/?page=3`` 时，也只会尝试匹配 ``myapp/`` 。"

#: ../../intro/tutorial01.txt:357
msgid ""
"If you need help with regular expressions, see `Wikipedia's entry`_ and "
"the documentation of the :mod:`re` module. Also, the O'Reilly book "
"\"Mastering Regular Expressions\" by Jeffrey Friedl is fantastic. In "
"practice, however, you don't need to be an expert on regular expressions,"
" as you really only need to know how to capture simple patterns. In fact,"
" complex regexes can have poor lookup performance, so you probably "
"shouldn't rely on the full power of regexes."
msgstr ""
"如果你需要一些关于正则表达式的帮助，看看维基百科 `Wikipedia's entry`_ 的条目或者 Python 的 :mod:`re` "
"模块的文档。另外，Jeffrey Friedl 的《Mastering Regular "
"Expressions》这本书也很值得推荐。然而，在我们的实际使用中，你不不需要非常精通正则表达式，你只需要了解如何捕获简单的模式就够了。事实上，复杂的正则表达式的查找性能会更低，所以，最好不要过度依赖正则表达式的强大功能。"

#: ../../intro/tutorial01.txt:364
msgid ""
"Finally, a performance note: these regular expressions are compiled the "
"first time the URLconf module is loaded. They're super fast (as long as "
"the lookups aren't too complex as noted above)."
msgstr ""
"最后，做一些性能方面的说明：在 URLconf "
"第一次被加载的时候，那些正则表达式都会被自动编译。编译过后的正则表达式相当的(只要他们不像上面提到的那样非常复杂的话)。"

#: ../../intro/tutorial01.txt:371
msgid ":func:`~django.conf.urls.url` argument: view"
msgstr ":func:`~django.conf.urls.url` 参数: view"

#: ../../intro/tutorial01.txt:373
msgid ""
"When Django finds a regular expression match, Django calls the specified "
"view function, with an :class:`~django.http.HttpRequest` object as the "
"first argument and any “captured” values from the regular expression as "
"other arguments. If the regex uses simple captures, values are passed as "
"positional arguments; if it uses named captures, values are passed as "
"keyword arguments. We'll give an example of this in a bit."
msgstr ""
"当 Django 找到匹配的正则表达式时，就会调用这个视图函数。调用时传递的第一个参数是一个 "
":class:`~django.http.HttpRequest` "
"对象，后续的参数是所有被正则表达数捕捉的部分。如果正则式使用简单捕获，捕获结果会作为位置参数传递；如果使用名字捕获，捕获结果会作为关键字参数传递。我们稍后会给出例子。"

#: ../../intro/tutorial01.txt:381
msgid ":func:`~django.conf.urls.url` argument: kwargs"
msgstr ":func:`~django.conf.urls.url` 参数: kwargs"

#: ../../intro/tutorial01.txt:383
msgid ""
"Arbitrary keyword arguments can be passed in a dictionary to the target "
"view. We aren't going to use this feature of Django in the tutorial."
msgstr "任意个关键字参数可以作为一个字典传递给目标视图函数。在我们的教程中不会使用这一特性。"

#: ../../intro/tutorial01.txt:387
msgid ":func:`~django.conf.urls.url` argument: name"
msgstr ":func:`~django.conf.urls.url` 参数: name"

#: ../../intro/tutorial01.txt:389
msgid ""
"Naming your URL lets you refer to it unambiguously from elsewhere in "
"Django especially templates. This powerful feature allows you to make  "
"global changes to the url patterns of your project while only touching a "
"single file."
msgstr "给你的 URL 起个名字，让你能在 Django 的模板里无二义性的引用到它。这个非常有用的特性允许你只用更改一个文件就能全局性的改变某个 URL。"

#: ../../intro/tutorial01.txt:393
msgid ""
"When you're comfortable with the basic request and response flow, read "
":doc:`part 2 of this tutorial </intro/tutorial02>` to start working with "
"the database."
msgstr "当你了解了基本的请求和响应流程后，请阅读 :doc:`本教程的第二部分 </intro/tutorial02>`  开始使用数据库."

#: ../../intro/tutorial02.txt:3
msgid "Writing your first Django app, part 2"
msgstr "编写你的第一个Django应用，第2部分"

#: ../../intro/tutorial02.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 1 </intro/tutorial01>` left "
"off. We'll setup the database, create your first model, and get a quick "
"introduction to Django's automatically-generated admin site."
msgstr ""
"这部分教程从 :doc:`第1部分 </intro/tutorial01>`  结尾的地方继续讲起. 我们将建立数据库, "
"创建您的第一个模型,并主要关注 Django 提供的自动生成的管理页面"

#: ../../intro/tutorial02.txt:10
msgid "Database setup"
msgstr "数据库配置"

#: ../../intro/tutorial02.txt:12
msgid ""
"Now, open up :file:`mysite/settings.py`. It's a normal Python module with"
" module-level variables representing Django settings."
msgstr "现在，打开 :file:`mysite/settings.py` 。这是包含着 Django 项目设置的 Python 模块。"

#: ../../intro/tutorial02.txt:15
msgid ""
"By default, the configuration uses SQLite. If you're new to databases, or"
" you're just interested in trying Django, this is the easiest choice. "
"SQLite is included in Python, so you won't need to install anything else "
"to support your database. When starting your first real project, however,"
" you may want to use a more robust database like PostgreSQL, to avoid "
"database-switching headaches down the road."
msgstr ""
"通常，这个配置文件将会使用 SQLite 作为默认数据库。如果你不熟悉数据库，或者只是想尝试一下 Django，使用 SQLite "
"会是最简单的选择。 Python 已经内置了 SQLite "
"支持，所以你不需要安装任何其他东西就可以使用它。当你开始第一个真正的项目时，你可能倾向于从一开始就使用更强大的数据库，比如 "
"PostgreSQL，来避免中途切换数据库这个令人头痛的问题。"

#: ../../intro/tutorial02.txt:22
msgid ""
"If you wish to use another database, install the appropriate "
":ref:`database bindings <database-installation>` and change the following"
" keys in the :setting:`DATABASES` ``'default'`` item to match your "
"database connection settings:"
msgstr ""
"如果你想使用其他数据库，你需要安装合适的 :ref:`database bindings <database-installation>` "
"，然后改变设置文件中 :setting:`DATABASES` ``'default'``  项目中的一些键值："

#: ../../intro/tutorial02.txt:27
msgid ""
":setting:`ENGINE <DATABASE-ENGINE>` -- Either "
"``'django.db.backends.sqlite3'``, ``'django.db.backends.postgresql'``, "
"``'django.db.backends.mysql'``, or ``'django.db.backends.oracle'``. Other"
" backends are :ref:`also available <third-party-notes>`."
msgstr ""
":setting:`ENGINE <DATABASE-ENGINE>` -- 可选值有 "
"``'django.db.backends.sqlite3'``, ``'django.db.backends.postgresql'``, "
"``'django.db.backends.mysql'``, 或 ``'django.db.backends.oracle'``. 其它 "
":ref:`可用后端 <third-party-notes>` ."

#: ../../intro/tutorial02.txt:34
msgid ""
":setting:`NAME` -- The name of your database. If you're using SQLite, the"
" database will be a file on your computer; in that case, :setting:`NAME` "
"should be the full absolute path, including filename, of that file. The "
"default value, ``os.path.join(BASE_DIR, 'db.sqlite3')``, will store the "
"file in your project directory."
msgstr ""
":setting:`NAME`  - 数据库的名称。如果使用的是 SQLite，数据库将是你电脑上的一个文件，在这种情况下， "
":setting:`NAME`  应该是此文件的绝对路径，包括文件名。默认值 ``os.path.join(BASE_DIR, "
"'db.sqlite3')`` 将会把数据库文件储存在项目的根目录。"

#: ../../intro/tutorial02.txt:40
msgid ""
"If you are not using SQLite as your database, additional settings such as"
" :setting:`USER`, :setting:`PASSWORD`, and :setting:`HOST` must be added."
" For more details, see the reference documentation for "
":setting:`DATABASES`."
msgstr ""
"如果你不是使用 SQLite，则必须添加一些额外设置，比如 :setting:`USER` 、 :setting:`PASSWORD` 、  "
":setting:`HOST`  等等。想了解更多数据库设置方面的内容，请看文档：:setting:`DATABASES` 。"

#: ../../intro/tutorial02.txt:44
msgid "For databases other than SQLite"
msgstr "SQLite 以外的其它数据库"

#: ../../intro/tutorial02.txt:46
msgid ""
"If you're using a database besides SQLite, make sure you've created a "
"database by this point. Do that with \"``CREATE DATABASE "
"database_name;``\" within your database's interactive prompt."
msgstr ""
"如果你使用了SQLite以外的数据库，请确认在使用前已经创建了数据库。你可以通过在你的数据库交互式命令行中使用 \"``CREATE "
"DATABASE database_name;``\"  命令来完成这件事。"

#: ../../intro/tutorial02.txt:50
msgid ""
"Also make sure that the database user provided in "
":file:`mysite/settings.py` has \"create database\" privileges. This "
"allows automatic creation of a :ref:`test database <the-test-database>` "
"which will be needed in a later tutorial."
msgstr ""
"另外，还要确保该数据库用户中提供  :file:`mysite/settings.py` 具有 \"create database\"  "
"权限。这使得自动创建的  :ref:`test database <the-test-database>`  将在以后的教程需要。"

#: ../../intro/tutorial02.txt:55
msgid ""
"If you're using SQLite, you don't need to create anything beforehand - "
"the database file will be created automatically when it is needed."
msgstr "如果你使用 SQLite，那么你不需要在使用前做任何事 - 数据库会在需要的时候自动创建。"

#: ../../intro/tutorial02.txt:58
msgid ""
"While you're editing :file:`mysite/settings.py`, set :setting:`TIME_ZONE`"
" to your time zone."
msgstr "当编辑 :file:`mysite/settings.py` 文件时,先设置 :setting:`TIME_ZONE` to 为你自己时区."

#: ../../intro/tutorial02.txt:61
msgid ""
"Also, note the :setting:`INSTALLED_APPS` setting at the top of the file. "
"That holds the names of all Django applications that are activated in "
"this Django instance. Apps can be used in multiple projects, and you can "
"package and distribute them for use by others in their projects."
msgstr ""
"此外，关注一下文件头部的 :setting:`INSTALLED_APPS`  设置项，这里包括了会在你项目中启用的所有 Django "
"应用。应用能在多个项目中使用，你也可以打包并且发布应用，让别人使用它们。"

#: ../../intro/tutorial02.txt:66
msgid ""
"By default, :setting:`INSTALLED_APPS` contains the following apps, all of"
" which come with Django:"
msgstr "通常， :setting:`INSTALLED_APPS`  默认包括了以下 Django 的自带应用："

#: ../../intro/tutorial02.txt:69
msgid ":mod:`django.contrib.admin` -- The admin site. You'll use it shortly."
msgstr ":mod:`django.contrib.admin` --  管理员站点， 你很快就会使用它。"

#: ../../intro/tutorial02.txt:71
msgid ":mod:`django.contrib.auth` -- An authentication system."
msgstr ":mod:`django.contrib.auth` -- 验证系统。"

#: ../../intro/tutorial02.txt:73
msgid ":mod:`django.contrib.contenttypes` -- A framework for content types."
msgstr ":mod:`django.contrib.contenttypes` -- 内容类型框架."

#: ../../intro/tutorial02.txt:75
msgid ":mod:`django.contrib.sessions` -- A session framework."
msgstr ":mod:`django.contrib.sessions` -- 会话框架."

#: ../../intro/tutorial02.txt:77
msgid ":mod:`django.contrib.messages` -- A messaging framework."
msgstr ":mod:`django.contrib.messages` -- 消息框架."

#: ../../intro/tutorial02.txt:79
msgid ""
":mod:`django.contrib.staticfiles` -- A framework for managing static "
"files."
msgstr ":mod:`django.contrib.staticfiles` -- 管理静态文件的框架."

#: ../../intro/tutorial02.txt:82
msgid ""
"These applications are included by default as a convenience for the "
"common case."
msgstr "这些应用被默认启用是为了给常规项目提供方便。"

#: ../../intro/tutorial02.txt:84
msgid ""
"Some of these applications make use of at least one database table, "
"though, so we need to create the tables in the database before we can use"
" them. To do that, run the following command:"
msgstr "默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表。请执行以下命令："

#: ../../intro/tutorial02.txt:92
msgid ""
"The :djadmin:`migrate` command looks at the :setting:`INSTALLED_APPS` "
"setting and creates any necessary database tables according to the "
"database settings in your :file:`mysite/settings.py` file and the "
"database migrations shipped with the app (we'll cover those later). "
"You'll see a message for each migration it applies. If you're interested,"
" run the command-line client for your database and type ``\\dt`` "
"(PostgreSQL), ``SHOW TABLES;`` (MySQL), ``.schema`` (SQLite), or ``SELECT"
" TABLE_NAME FROM USER_TABLES;`` (Oracle) to display the tables Django "
"created."
msgstr ""
"这个 :djadmin:`migrate`  命令检查 :setting:`INSTALLED_APPS` "
"设置，为其中的每个应用创建需要的数据表，至于具体会创建什么，这取决于你的 :file:`mysite/settings.py` "
"设置文件和每个应用的数据库迁移文件(我们稍后会介绍这个)。这个命令所执行的每个迁移操作都会在终端中显示出来。如果你感兴趣的话，运行你数据库的命令行工具，并输入"
" ``\\dt``  (PostgreSQL)， ``SHOW TABLES;`` (MySQL)， ``.schema`` (SQLite)或者"
" ``SELECT TABLE_NAME FROM USER_TABLES;`` (Oracle) 来看看 Django 到底创建了哪些表。"

#: ../../intro/tutorial02.txt:101
msgid "For the minimalists"
msgstr "写给极简主义者"

#: ../../intro/tutorial02.txt:103
msgid ""
"Like we said above, the default applications are included for the common "
"case, but not everybody needs them. If you don't need any or all of them,"
" feel free to comment-out or delete the appropriate line(s) from "
":setting:`INSTALLED_APPS` before running :djadmin:`migrate`. The "
":djadmin:`migrate` command will only run migrations for apps in "
":setting:`INSTALLED_APPS`."
msgstr ""
"就像之前说的，为了方便大多数项目，我们默认激活了一些应用，但并不是每个人都需要它们。如果你不需要某个或某些应用(s)，你可以在运行 "
":djadmin:`migrate`  前毫无顾虑的从 :setting:`INSTALLED_APPS`  里注释或者删除掉它们。 "
":djadmin:`migrate` 命令只会为在 :setting:`INSTALLED_APPS`  里声明了的应用进行数据库迁移。"

#: ../../intro/tutorial02.txt:113
msgid "Creating models"
msgstr "创建模型"

#: ../../intro/tutorial02.txt:115
msgid ""
"Now we'll define your models -- essentially, your database layout, with "
"additional metadata."
msgstr "在 Django 里写一个数据库驱动的 Web 应用的第一步是定义模型 - 也就是数据库结构设计和附加的其他元数据。"

#: ../../intro/tutorial02.txt:118 ../../intro/tutorial02.txt:201
#: ../../intro/tutorial02.txt:582 ../../intro/tutorial03.txt:331
msgid "Philosophy"
msgstr "设计哲学"

#: ../../intro/tutorial02.txt:120
msgid ""
"A model is the single, definitive source of truth about your data. It "
"contains the essential fields and behaviors of the data you're storing. "
"Django follows the :ref:`DRY Principle <dry>`. The goal is to define your"
" data model in one place and automatically derive things from it."
msgstr ""
"模型是真实数据的简单明确的描述。它包含了储存的数据所必要的字段和行为。Django 遵循 :ref:`DRY Principle <dry>` "
"。它的目标是你只需要定义数据模型，然后其他的杂七杂八代码你都不用关心，它们会自动从模型生成。"

#: ../../intro/tutorial02.txt:125
msgid ""
"This includes the migrations - unlike in Ruby On Rails, for example, "
"migrations are entirely derived from your models file, and are "
"essentially just a history that Django can roll through to update your "
"database schema to match your current models."
msgstr ""
"来介绍一下迁移 - 举个例子，不像 Ruby On Rails，Django "
"的迁移代码是由你的模型文件自动生成的，它本质上只是个历史记录，Django 可以用它来进行数据库的滚动更新，通过这种方式使其能够和当前的模型匹配。"

#: ../../intro/tutorial02.txt:130
msgid ""
"In our simple poll app, we'll create two models: ``Question`` and "
"``Choice``. A ``Question`` has a question and a publication date. A "
"``Choice`` has two fields: the text of the choice and a vote tally. Each "
"``Choice`` is associated with a ``Question``."
msgstr "在这个简单的投票应用中，需要创建两个模型：问题``Question``和选项``Choice``。问题模型包括问题描述和发布时间。选项模型有两个字段，选项描述和当前得票数。每个选项属于一个问题。"

#: ../../intro/tutorial02.txt:135
msgid ""
"These concepts are represented by simple Python classes. Edit the "
":file:`polls/models.py` file so it looks like this:"
msgstr "这些概念可以通过一个简单的 Python 类来描述。按照下面的例子来编辑 :file:`polls/models.py` 文件："

#: ../../intro/tutorial02.txt:154
msgid ""
"The code is straightforward. Each model is represented by a class that "
"subclasses :class:`django.db.models.Model`. Each model has a number of "
"class variables, each of which represents a database field in the model."
msgstr ""
"代码非常直白。每个模型被表示为 :class:`django.db.models.Model` "
"类的子类。每个模型有一些类变量，它们都表示模型里的一个数据库字段。"

#: ../../intro/tutorial02.txt:158
msgid ""
"Each field is represented by an instance of a "
":class:`~django.db.models.Field` class -- e.g., "
":class:`~django.db.models.CharField` for character fields and "
":class:`~django.db.models.DateTimeField` for datetimes. This tells Django"
" what type of data each field holds."
msgstr ""
"每个字段都是 :class:`~django.db.models.Field` 类的实例 - 比如，字符字段被表示为 "
":class:`~django.db.models.CharField` ，日期时间字段被表示为 "
":class:`~django.db.models.DateTimeField` 。这将告诉 Django 每个字段要处理的数据类型。"

#: ../../intro/tutorial02.txt:163
msgid ""
"The name of each :class:`~django.db.models.Field` instance (e.g. "
"``question_text`` or ``pub_date``) is the field's name, in machine-"
"friendly format. You'll use this value in your Python code, and your "
"database will use it as the column name."
msgstr ""
"每个 :class:`~django.db.models.Field` 类实例变量的名字(例如 ``question_text`` 或 "
"``pub_date`` )也是字段名，所以最好使用对机器友好的格式。你将会在 Python 代码里使用它们，而数据库会将它们作为列名。"

#: ../../intro/tutorial02.txt:168
msgid ""
"You can use an optional first positional argument to a "
":class:`~django.db.models.Field` to designate a human-readable name. "
"That's used in a couple of introspective parts of Django, and it doubles "
"as documentation. If this field isn't provided, Django will use the "
"machine-readable name. In this example, we've only defined a human-"
"readable name for ``Question.pub_date``. For all other fields in this "
"model, the field's machine-readable name will suffice as its human-"
"readable name."
msgstr ""
"你可以使用可选的选项来为 :class:`~django.db.models.Field`  定义一个人类可读的名字。这个功能在很多 Django"
" 内部组成部分中都被使用了，而且作为文档的一部分。如果某个字段没有提供此名称，Django "
"将会使用对机器友好的名称,也就是变量名。在上面的例子中，我们只为  ``Question.pub_date`` "
"定义了对人类友好的名字。对于模型内的其他字段，他们的机器友好名也会被作为人类友好名使用。"

#: ../../intro/tutorial02.txt:176
msgid ""
"Some :class:`~django.db.models.Field` classes have required arguments. "
":class:`~django.db.models.CharField`, for example, requires that you give"
" it a :attr:`~django.db.models.CharField.max_length`. That's used not "
"only in the database schema, but in validation, as we'll soon see."
msgstr ""
"定义某些 :class:`~django.db.models.Field`  类实例需要参数。例如 "
":class:`~django.db.models.CharField`  需要一个 "
":attr:`~django.db.models.CharField.max_length`  "
"参数。这个参数的用处不止于用来定义数据库结构，也用于验证数据，我们稍后将会看到这方面的内容。"

#: ../../intro/tutorial02.txt:181
msgid ""
"A :class:`~django.db.models.Field` can also have various optional "
"arguments; in this case, we've set the "
":attr:`~django.db.models.Field.default` value of ``votes`` to 0."
msgstr ""
"A :class:`~django.db.models.Field` can also have various optional "
"arguments; in this case, we've set the "
":attr:`~django.db.models.Field.default` value of ``votes`` to 0."

#: ../../intro/tutorial02.txt:185
msgid ""
"Finally, note a relationship is defined, using "
":class:`~django.db.models.ForeignKey`. That tells Django each ``Choice`` "
"is related to a single ``Question``. Django supports all the common "
"database relationships: many-to-one, many-to-many, and one-to-one."
msgstr ""
"注意在最后，我们使用 :class:`~django.db.models.ForeignKey` 。定义了一个关系。这将告诉 Django，每个 "
"``Choice`` 对象都关联到一个  ``Question``  对象。Django 支持所有常用的数据库关系：多对一、多对多和一对一。"

#: ../../intro/tutorial02.txt:191
msgid "Activating models"
msgstr "使用模型"

#: ../../intro/tutorial02.txt:193
msgid ""
"That small bit of model code gives Django a lot of information. With it, "
"Django is able to:"
msgstr "上面的一小段用于创建模型的代码给了 Django 很多信息，通过这些信息，Django 可以："

#: ../../intro/tutorial02.txt:196
msgid "Create a database schema (``CREATE TABLE`` statements) for this app."
msgstr "为这个应用创建数据库结构(生成 ``CREATE TABLE`` 语句)。"

#: ../../intro/tutorial02.txt:197
msgid ""
"Create a Python database-access API for accessing ``Question`` and "
"``Choice`` objects."
msgstr "创建可以与 ``Question`` 和 ``Choice`` 对象进行交互的 Python 数据库 API。"

#: ../../intro/tutorial02.txt:199
msgid "But first we need to tell our project that the ``polls`` app is installed."
msgstr "但是首先得把 ``polls`` 应用安装到我们的项目里。"

#: ../../intro/tutorial02.txt:203
msgid ""
"Django apps are \"pluggable\": You can use an app in multiple projects, "
"and you can distribute apps, because they don't have to be tied to a "
"given Django installation."
msgstr ""
"Django 应用是\"可插拔\"的。你可以在多个项目中使用同一个应用。除此之外，你还可以发布自己的应用，因为它们并不会被绑定到当前安装的 "
"Django 上。"

#: ../../intro/tutorial02.txt:207
msgid ""
"Edit the :file:`mysite/settings.py` file again, and change the "
":setting:`INSTALLED_APPS` setting to include the string "
"``'polls.apps.PollsConfig'``. It'll look like this:"
msgstr ""
"再次编辑  :file:`mysite/settings.py` ，改变  :setting:`INSTALLED_APPS`   "
"设置，使其包含字符串 ``'polls.apps.PollsConfig'`` 。它现在看起来应该像这样："

#: ../../intro/tutorial02.txt:224
msgid "Now Django knows to include the ``polls`` app. Let's run another command:"
msgstr "现在你的 Django 项目会包含 ``polls``  应用。接着运行下面的命令"

#: ../../intro/tutorial02.txt:230
msgid "You should see something similar to the following:"
msgstr "你将会看到类似于下面这样的输出："

#: ../../intro/tutorial02.txt:240
msgid ""
"By running ``makemigrations``, you're telling Django that you've made "
"some changes to your models (in this case, you've made new ones) and that"
" you'd like the changes to be stored as a *migration*."
msgstr ""
"通过 ``makemigrations`` 命令，Django "
"会检测你对模型文件的修改(在这种情况下，你已经取得了新的)，并且把修改的部分储存为一次 *迁移*。"

#: ../../intro/tutorial02.txt:244
msgid ""
"Migrations are how Django stores changes to your models (and thus your "
"database schema) - they're just files on disk. You can read the migration"
" for your new model if you like; it's the file "
"``polls/migrations/0001_initial.py``. Don't worry, you're not expected to"
" read them every time Django makes one, but they're designed to be human-"
"editable in case you want to manually tweak how Django changes things."
msgstr ""
"迁移是 Django 对于模型定义(也就是你的数据库结构)的变化的储存形式 - "
"没那么玄乎，它们其实也只是一些你磁盘上的文件。如果你想的话，你可以阅读一下你模型的迁移数据，它被储存在 "
"``polls/migrations/0001_initial.py`` "
"里。别担心，你不需要每次都阅读迁移文件，但是它们被设计成人类可读的形式，这是为了便于你手动修改它们。"

#: ../../intro/tutorial02.txt:251
msgid ""
"There's a command that will run the migrations for you and manage your "
"database schema automatically - that's called :djadmin:`migrate`, and "
"we'll come to it in a moment - but first, let's see what SQL that "
"migration would run. The :djadmin:`sqlmigrate` command takes migration "
"names and returns their SQL:"
msgstr ""
"Django 有一个自动执行数据库迁移并同步管理你的数据库结构的命令 - 这个命令是 :djadmin:`migrate` ，我们马上就会接触它 "
"- 但是首先，让我们看看迁移命令会执行哪些 SQL 语句。:djadmin:`sqlmigrate`   "
"命令接收一个迁移的名称，然后返回给你对应的 SQL："

#: ../../intro/tutorial02.txt:260
msgid ""
"You should see something similar to the following (we've reformatted it "
"for readability):"
msgstr "你将会看到类似下面这样的输出(我把输出重组成了人类可读的格式)："

#: ../../intro/tutorial02.txt:296
msgid "Note the following:"
msgstr "请注意以下几点："

#: ../../intro/tutorial02.txt:298
msgid ""
"The exact output will vary depending on the database you are using. The "
"example above is generated for PostgreSQL."
msgstr "输出的内容和你使用的数据库有关，上面的输出示例使用的是 PostgreSQL。"

#: ../../intro/tutorial02.txt:301
msgid ""
"Table names are automatically generated by combining the name of the app "
"(``polls``) and the lowercase name of the model -- ``question`` and "
"``choice``. (You can override this behavior.)"
msgstr ""
"数据库的表名是由应用名( ``polls``)和模型名的小写形式( ``question`` 和  ``choice`` "
".)连接而来。（如果需要，你可以自定义此行为。）"

#: ../../intro/tutorial02.txt:305
msgid "Primary keys (IDs) are added automatically. (You can override this, too.)"
msgstr "主键(IDs)会被自动创建。(当然，你也可以自定义。)"

#: ../../intro/tutorial02.txt:307
msgid ""
"By convention, Django appends ``\"_id\"`` to the foreign key field name. "
"(Yes, you can override this, as well.)"
msgstr "默认的，Django 会在外键字段名后追加字符串 ``\"_id\"`` 。(同样，这也可以自定义。)"

#: ../../intro/tutorial02.txt:310
msgid ""
"The foreign key relationship is made explicit by a ``FOREIGN KEY`` "
"constraint. Don't worry about the ``DEFERRABLE`` parts; that's just "
"telling PostgreSQL to not enforce the foreign key until the end of the "
"transaction."
msgstr ""
"外键关系由 ``FOREIGN KEY`` 生成。你不用关心 ``DEFERRABLE``  部分，它只是告诉 "
"PostgreSQL，请在事务全都执行完之后再创建外键关系。"

#: ../../intro/tutorial02.txt:314
msgid ""
"It's tailored to the database you're using, so database-specific field "
"types such as ``auto_increment`` (MySQL), ``serial`` (PostgreSQL), or "
"``integer primary key autoincrement`` (SQLite) are handled for you "
"automatically. Same goes for the quoting of field names -- e.g., using "
"double quotes or single quotes."
msgstr ""
"生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 ``auto_increment`` (MySQL)、 "
"``serial`` (PostgreSQL)和  ``integer primary key autoincrement`` "
"(SQLite)，Django 会帮你自动处理。那些和引号相关的事情 - 例如，是使用单引号还是双引号 - 也一样会被自动处理。"

#: ../../intro/tutorial02.txt:320
msgid ""
"The :djadmin:`sqlmigrate` command doesn't actually run the migration on "
"your database - it just prints it to the screen so that you can see what "
"SQL Django thinks is required. It's useful for checking what Django is "
"going to do or if you have database administrators who require SQL "
"scripts for changes."
msgstr ""
"这个 :djadmin:`sqlmigrate` 命令并没有真正在你的数据库中的执行迁移 - 它只是把命令输出到屏幕上，让你看看 Django "
"认为需要执行哪些 SQL 语句。这在你想看看 Django 到底准备做什么，或者当你是数据库管理员，需要写脚本来批量处理数据库时会很有用。"

#: ../../intro/tutorial02.txt:326
msgid ""
"If you're interested, you can also run :djadmin:`python manage.py check "
"<check>`; this checks for any problems in your project without making "
"migrations or touching the database."
msgstr ""
"如果你感兴趣，你也可以试试运行 :djadmin:`python manage.py check <check>` "
";这个命令帮助你检查项目中的问题，并且在检查过程中不会对数据库进行任何操作。"

#: ../../intro/tutorial02.txt:330
msgid ""
"Now, run :djadmin:`migrate` again to create those model tables in your "
"database:"
msgstr "现在，再次运行 :djadmin:`migrate` 命令，在数据库里创建新定义的模型的数据表："

#: ../../intro/tutorial02.txt:341
msgid ""
"The :djadmin:`migrate` command takes all the migrations that haven't been"
" applied (Django tracks which ones are applied using a special table in "
"your database called ``django_migrations``) and runs them against your "
"database - essentially, synchronizing the changes you made to your models"
" with the schema in the database."
msgstr ""
"这个 :djadmin:`migrate` 命令选中所有还没有执行过的迁移(Django 通过在数据库中创建一个特殊的表 "
"``django_migrations`` 来跟踪执行过哪些迁移)并应用在数据库上 - 也就是将你对模型的更改同步到数据库结构上。"

#: ../../intro/tutorial02.txt:347
msgid ""
"Migrations are very powerful and let you change your models over time, as"
" you develop your project, without the need to delete your database or "
"tables and make new ones - it specializes in upgrading your database "
"live, without losing data. We'll cover them in more depth in a later part"
" of the tutorial, but for now, remember the three-step guide to making "
"model changes:"
msgstr ""
"迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表 - "
"它专注于使数据库平滑升级而不会丢失数据。我们会在后面的教程中更加深入的学习这部分内容，现在，你只需要记住，改变模型需要这三步："

#: ../../intro/tutorial02.txt:353
msgid "Change your models (in ``models.py``)."
msgstr "编辑 ``models.py`` 文件，改变模型。"

#: ../../intro/tutorial02.txt:354
msgid ""
"Run :djadmin:`python manage.py makemigrations <makemigrations>` to create"
" migrations for those changes"
msgstr ""
"运行 :djadmin:`python manage.py makemigrations <makemigrations>`   "
"为模型的改变生成迁移文件。"

#: ../../intro/tutorial02.txt:356
msgid ""
"Run :djadmin:`python manage.py migrate <migrate>` to apply those changes "
"to the database."
msgstr "运行  :djadmin:`python manage.py migrate <migrate>`  来应用数据库迁移。"

#: ../../intro/tutorial02.txt:359
msgid ""
"The reason that there are separate commands to make and apply migrations "
"is because you'll commit migrations to your version control system and "
"ship them with your app; they not only make your development easier, "
"they're also useable by other developers and in production."
msgstr "数据库迁移被分解成生成和应用两个命令是为了让你能够在代码控制系统上提交迁移数据并使其能在多个应用里使用；这不仅仅会让开发更加简单，也给别的开发者和生产环境中的使用带来方便。"

#: ../../intro/tutorial02.txt:364
msgid ""
"Read the :doc:`django-admin documentation </ref/django-admin>` for full "
"information on what the ``manage.py`` utility can do."
msgstr ""
"通过阅读文档 :doc:`django-admin documentation </ref/django-admin>` ，你可以获得关于 "
"``manage.py`` 工具的更多信息。"

#: ../../intro/tutorial02.txt:368
msgid "Playing with the API"
msgstr "初试 API"

#: ../../intro/tutorial02.txt:370
msgid ""
"Now, let's hop into the interactive Python shell and play around with the"
" free API Django gives you. To invoke the Python shell, use this command:"
msgstr "现在让我们进入交互式 Python 命令行，尝试一下 Django 为你创建的各种 API。通过以下命令打开 Python 命令行："

#: ../../intro/tutorial02.txt:377
msgid ""
"We're using this instead of simply typing \"python\", because "
":file:`manage.py` sets the ``DJANGO_SETTINGS_MODULE`` environment "
"variable, which gives Django the Python import path to your "
":file:`mysite/settings.py` file."
msgstr ""
"我们使用这个命令而不是简单的使用 \"Python\" 是因为 :file:`manage.py` 会设置 "
"``DJANGO_SETTINGS_MODULE`` 环境变量，这个变量会让 Django 根据 "
":file:`mysite/settings.py` 文件来设置 Python 包的导入路径。"

#: ../../intro/tutorial02.txt:381
msgid "Bypassing manage.py"
msgstr ""

#: ../../intro/tutorial02.txt:383
msgid ""
"If you'd rather not use :file:`manage.py`, no problem. Just set the "
":envvar:`DJANGO_SETTINGS_MODULE` environment variable to "
"``mysite.settings``, start a plain Python shell, and set up Django:"
msgstr ""
"如果你不想使用 :file:`manage.py` ，没问题，你只要手动将 :envvar:`DJANGO_SETTINGS_MODULE` "
"环境变量设置为 ``mysite.settings`` 就行。打开一个普通的 Python 命令行，然后输入以下命令来配置 Django： "

#: ../../intro/tutorial02.txt:392
msgid ""
"If this raises an :exc:`AttributeError`, you're probably using a version "
"of Django that doesn't match this tutorial version. You'll want to either"
" switch to the older tutorial or the newer Django version."
msgstr ""
"如果抛出了 :exc:`AttributeError` ，那么说明你使用的 Django 版本可能和本教程不匹配。你可以切换到旧版本的教程或者把 "
"Django 升级至最新版本。"

#: ../../intro/tutorial02.txt:396
msgid ""
"You must run ``python`` from the same directory :file:`manage.py` is in, "
"or ensure that directory is on the Python path, so that ``import mysite``"
" works."
msgstr ""
"你必须在 :file:`manage.py`  所在目录中运行 ``python``  命令，或者确保这个目录在 Python path "
"里，因为只有这样 ``import mysite``  才能被正确的执行。"

#: ../../intro/tutorial02.txt:400
msgid ""
"For more information on all of this, see the :doc:`django-admin "
"documentation </ref/django-admin>`."
msgstr "阅读文档 :doc:`django-admin documentation </ref/django-admin>` 获取更多信息。"

#: ../../intro/tutorial02.txt:403
msgid ""
"Once you're in the shell, explore the :doc:`database API "
"</topics/db/queries>`::"
msgstr "当你成功进入命令行后，来试试 数据库 :doc:`database API </topics/db/queries>`  吧::"

#: ../../intro/tutorial02.txt:442
msgid ""
"Wait a minute. ``<Question: Question object>`` is, utterly, an unhelpful "
"representation of this object. Let's fix that by editing the ``Question``"
" model (in the ``polls/models.py`` file) and adding a "
":meth:`~django.db.models.Model.__str__` method to both ``Question`` and "
"``Choice``:"
msgstr ""
"等等。用 ``<Question: Question object>``  "
"表示这个对象没什么意思，它无法告诉我们这个对象的详细信息。让我们通过编辑 Question 模型的代码( ``polls/models.py``"
"  文件)，给 ``Question``  和 ``Choice`` 增加 "
":meth:`~django.db.models.Model.__str__`  方法来改善这个问题："

#: ../../intro/tutorial02.txt:466
msgid ""
"It's important to add :meth:`~django.db.models.Model.__str__` methods to "
"your models, not only for your own convenience when dealing with the "
"interactive prompt, but also because objects' representations are used "
"throughout Django's automatically-generated admin."
msgstr ""
"给模型增加 :meth:`~django.db.models.Model.__str__`  "
"方法是很重要的，这不仅仅能给你在命令行里使用带来方便，Django 自动生成的 admin 里也使用这个方法来表示对象。"

#: ../../intro/tutorial02.txt:471
msgid ""
"Note these are normal Python methods. Let's add a custom method, just for"
" demonstration:"
msgstr "注意：这些都是常规的 Python方法。让我们添加一个自定义的方法，这只是为了演示："

#: ../../intro/tutorial02.txt:488
msgid ""
"Note the addition of ``import datetime`` and ``from django.utils import "
"timezone``, to reference Python's standard :mod:`datetime` module and "
"Django's time-zone-related utilities in :mod:`django.utils.timezone`, "
"respectively. If you aren't familiar with time zone handling in Python, "
"you can learn more in the :doc:`time zone support docs "
"</topics/i18n/timezones>`."
msgstr ""
"新加入的 ``import datetime``  和 ``from django.utils import timezone``  分别导入了 "
"Python 的标准 :mod:`datetime`  模块和 Django 中和时区相关的 "
":mod:`django.utils.timezone` 工具模块。如果你不太熟悉 Python 中的时区处理，看看 :doc:`time "
"zone support docs </topics/i18n/timezones>` 文档吧。"

#: ../../intro/tutorial02.txt:494
msgid ""
"Save these changes and start a new Python interactive shell by running "
"``python manage.py shell`` again::"
msgstr "保存文件然后通过 ``python manage.py shell``  命令再次打开 Python 交互式命令行："

#: ../../intro/tutorial02.txt:573
msgid ""
"For more information on model relations, see :doc:`Accessing related "
"objects </ref/models/relations>`. For more on how to use double "
"underscores to perform field lookups via the API, see :ref:`Field lookups"
" <field-lookups-intro>`. For full details on the database API, see our "
":doc:`Database API reference </topics/db/queries>`."
msgstr ""
"阅读  :doc:`Accessing related objects </ref/models/relations>`  "
"文档可以获取关于数据库关系的更多内容。想知道关于双下划线的更多用法，参见 :ref:`Field lookups <field-lookups-"
"intro>` 文档。数据库 API 的所有细节可以在 :doc:`Database API reference "
"</topics/db/queries>` 文档中找到。"

#: ../../intro/tutorial02.txt:580
msgid "Introducing the Django Admin"
msgstr "介绍 Django 管理"

#: ../../intro/tutorial02.txt:584
msgid ""
"Generating admin sites for your staff or clients to add, change, and "
"delete content is tedious work that doesn't require much creativity. For "
"that reason, Django entirely automates creation of admin interfaces for "
"models."
msgstr ""

#: ../../intro/tutorial02.txt:588
msgid ""
"Django was written in a newsroom environment, with a very clear "
"separation between \"content publishers\" and the \"public\" site. Site "
"managers use the system to add news stories, events, sports scores, etc.,"
" and that content is displayed on the public site. Django solves the "
"problem of creating a unified interface for site administrators to edit "
"content."
msgstr ""
"Django "
"产生于一个公众页面和内容发布者页面完全分离的新闻类站点的开发过程中。站点管理人员使用管理系统来添加新闻、事件和体育时讯等，这些添加的内容被显示在公众页面上。Django"
" 通过为站点管理人员创建统一的内容编辑界面解决了这个问题。"

#: ../../intro/tutorial02.txt:594
msgid ""
"The admin isn't intended to be used by site visitors. It's for site "
"managers."
msgstr "管理界面不是为了网站的访问者，而是为管理者准备的。"

#: ../../intro/tutorial02.txt:598
msgid "Creating an admin user"
msgstr "输入你想使用的用户名，然后回车。"

#: ../../intro/tutorial02.txt:600
msgid ""
"First we'll need to create a user who can login to the admin site. Run "
"the following command:"
msgstr "首先，我们得创建一个能登录管理页面的用户。请运行下面的命令："

#: ../../intro/tutorial02.txt:607
msgid "Enter your desired username and press enter."
msgstr "键入你想要使用的用户名，然后按下回车键："

#: ../../intro/tutorial02.txt:613
msgid "You will then be prompted for your desired email address:"
msgstr "然后提示你输入想要使用的邮件地址："

#: ../../intro/tutorial02.txt:619
msgid ""
"The final step is to enter your password. You will be asked to enter your"
" password twice, the second time as a confirmation of the first."
msgstr "最后一步是输入密码。你会被要求输入两次密码，第二次的目的是为了确认第一次输入的确实是你想要的密码。"

#: ../../intro/tutorial02.txt:629
msgid "Start the development server"
msgstr "启动用于开发的服务器"

#: ../../intro/tutorial02.txt:631
msgid ""
"The Django admin site is activated by default. Let's start the "
"development server and explore it."
msgstr "Django 的管理界面默认就是启用的。让我们启动开发服务器，看看它到底是什么样的。"

#: ../../intro/tutorial02.txt:634
msgid "If the server is not running start it like so:"
msgstr "如果服务没有启动它就像这样："

#: ../../intro/tutorial02.txt:640
msgid ""
"Now, open a Web browser and go to \"/admin/\" on your local domain -- "
"e.g., http://127.0.0.1:8000/admin/. You should see the admin's login "
"screen:"
msgstr ""
"现在，打开浏览器，转到你本地域名的 \"/admin/\" 目录， -- 比如 \"http://127.0.0.1:8000/admin/\""
"  。你应该会看见管理员登录界面："

#: ../../intro/tutorial02.txt:646
msgid ""
"Since :doc:`translation </topics/i18n/translation>` is turned on by "
"default, the login screen may be displayed in your own language, "
"depending on your browser's settings and if Django has a translation for "
"this language."
msgstr ""
"因为 :doc:`翻译 </topics/i18n/translation>`  "
"功能默认是开着的，所以登录界面可能会使用你的语言，取决于你的浏览器设置和是否 Django 已被翻译成你的语言。"

#: ../../intro/tutorial02.txt:651
msgid "Enter the admin site"
msgstr "进入管理站点页面"

#: ../../intro/tutorial02.txt:653
msgid ""
"Now, try logging in with the superuser account you created in the "
"previous step. You should see the Django admin index page:"
msgstr "现在，试着使用你在上一步中创建的超级用户来登录。然后你将会看到 Django 管理页面的索引页"

#: ../../intro/tutorial02.txt:659
msgid ""
"You should see a few types of editable content: groups and users. They "
"are provided by :mod:`django.contrib.auth`, the authentication framework "
"shipped by Django."
msgstr "你将会看到几种可编辑的内容：组和用户。它们是  :mod:`django.contrib.auth`  提供的，这是 Django 开发的验证框架。"

#: ../../intro/tutorial02.txt:664
msgid "Make the poll app modifiable in the admin"
msgstr "向管理页面中加入投票应用"

#: ../../intro/tutorial02.txt:666
msgid "But where's our poll app? It's not displayed on the admin index page."
msgstr "但是我们的投票应用在哪呢？它没在索引页面里显示。"

#: ../../intro/tutorial02.txt:668
msgid ""
"Just one thing to do: we need to tell the admin that ``Question`` objects"
" have an admin interface. To do this, open the :file:`polls/admin.py` "
"file, and edit it to look like this:"
msgstr ""
"只需要做一件事：我们得告诉管理页面，问题 ``Question`` 对象需要被管理。打开 :file:`polls/admin.py` "
"文件，把它编辑成下面这样："

#: ../../intro/tutorial02.txt:682
msgid "Explore the free admin functionality"
msgstr "体验便捷的管理功能"

#: ../../intro/tutorial02.txt:684
msgid ""
"Now that we've registered ``Question``, Django knows that it should be "
"displayed on the admin index page:"
msgstr "现在我们向管理页面注册了问题 ``Question`` 类。Django 知道它应该被显示在索引页里："

#: ../../intro/tutorial02.txt:690
msgid ""
"Click \"Questions\". Now you're at the \"change list\" page for "
"questions. This page displays all the questions in the database and lets "
"you choose one to change it. There's the \"What's up?\" question we "
"created earlier:"
msgstr ""
"点击 \"Questions\" 。现在看到是问题 \"Questions\". 对象的列表 \"change list\" "
"。这个界面会显示所有数据库里的问题Question对象，你可以选择一个来修改。这里现在有我们在上一部分中创建的“What's up?”问题。"

#: ../../intro/tutorial02.txt:697
msgid "Click the \"What's up?\" question to edit it:"
msgstr "点击“What's up?”来编辑这个问题（Question）对象："

#: ../../intro/tutorial02.txt:702
msgid "Things to note here:"
msgstr "有些事情需要注意："

#: ../../intro/tutorial02.txt:704
msgid "The form is automatically generated from the ``Question`` model."
msgstr "这个表单是从问题（Question）模型中自动生成的"

#: ../../intro/tutorial02.txt:706
msgid ""
"The different model field types "
"(:class:`~django.db.models.DateTimeField`, "
":class:`~django.db.models.CharField`) correspond to the appropriate HTML "
"input widget. Each type of field knows how to display itself in the "
"Django admin."
msgstr ""
"不同的字段类型(日期时间字段 :class:`~django.db.models.DateTimeField`  、字符字段 "
":class:`~django.db.models.CharField`  )会生成对应的 HTML "
"输入控件。每个类型的字段都知道它们该如何在管理页面里显示自己。"

#: ../../intro/tutorial02.txt:711
msgid ""
"Each :class:`~django.db.models.DateTimeField` gets free JavaScript "
"shortcuts. Dates get a \"Today\" shortcut and calendar popup, and times "
"get a \"Now\" shortcut and a convenient popup that lists commonly entered"
" times."
msgstr ""
"每个 日期时间字段 :class:`~django.db.models.DateTimeField` 都有 JavaScript "
"写的快捷按钮。日期有转到今天（Today）的快捷按钮和一个弹出式日历界面。时间有设为现在（Now）的快捷按钮和一个列出常用时间的方便的弹出式列表。"

#: ../../intro/tutorial02.txt:715
msgid "The bottom part of the page gives you a couple of options:"
msgstr "页面的底部提供了几个选项："

#: ../../intro/tutorial02.txt:717
msgid ""
"Save -- Saves changes and returns to the change-list page for this type "
"of object."
msgstr "保存（Save） - 保存改变，然后返回对象列表。"

#: ../../intro/tutorial02.txt:720
msgid ""
"Save and continue editing -- Saves changes and reloads the admin page for"
" this object."
msgstr "保存并继续编辑（Save and continue editing） - 保存改变，然后重新载入当前对象的修改界面。"

#: ../../intro/tutorial02.txt:723
msgid ""
"Save and add another -- Saves changes and loads a new, blank form for "
"this type of object."
msgstr "保存并新增（Save and add another） - 保存改变，然后添加一个新的空对象并载入修改界面。"

#: ../../intro/tutorial02.txt:726
msgid "Delete -- Displays a delete confirmation page."
msgstr "删除（Delete） - 显示一个确认删除页面。"

#: ../../intro/tutorial02.txt:728
msgid ""
"If the value of \"Date published\" doesn't match the time when you "
"created the question in :doc:`Tutorial 1</intro/tutorial01>`, it probably"
" means you forgot to set the correct value for the :setting:`TIME_ZONE` "
"setting. Change it, reload the page and check that the correct value "
"appears."
msgstr ""
"如果显示的“发布日期（Date Published）”和你在 :doc:`教程第一部分</intro/tutorial01>` "
"里创建它们的时间不一致，这意味着你可能没有正确的设置 :setting:`TIME_ZONE` "
"。改变设置，然后重新载入页面看看是否显示了正确的值。"

#: ../../intro/tutorial02.txt:733
msgid ""
"Change the \"Date published\" by clicking the \"Today\" and \"Now\" "
"shortcuts. Then click \"Save and continue editing.\" Then click "
"\"History\" in the upper right. You'll see a page listing all changes "
"made to this object via the Django admin, with the timestamp and username"
" of the person who made the change:"
msgstr ""
"通过点击“今天”（Today）和“现在（Now）”按钮改变“发布日期（Date Published）”。然后点击“保存并继续编辑（Save and"
" add another）”按钮。然后点击右上角的“历史（History）”按钮。你会看到一个列出了所有通过 Django "
"管理页面对当前对象进行的改变的页面，其中列出了时间戳和进行修改操作的用户名："

#: ../../intro/tutorial02.txt:741
msgid ""
"When you're comfortable with the models API and have familiarized "
"yourself with the admin site, read :doc:`part 3 of this "
"tutorial</intro/tutorial03>` to learn about how to add more views to our "
"polls app."
msgstr ""
"当你熟悉了数据库 API 之后，你就可以开始阅读 :doc:`教程第三部分</intro/tutorial03>`  "
"，下一部分我们将会学习如何为投票应用添加更多视图。"

#: ../../intro/tutorial03.txt:3
msgid "Writing your first Django app, part 3"
msgstr "编写你的第一个Django应用，第3部分"

#: ../../intro/tutorial03.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 2 </intro/tutorial02>` left "
"off. We're continuing the Web-poll application and will focus on creating"
" the public interface -- \"views.\""
msgstr ""
"这一篇从 :doc:`教程第2部分 </intro/tutorial02>` "
"结尾的地方继续讲起。我们将继续编写投票应用，并且聚焦于如何创建公用界面——也被称为“视图”。"

#: ../../intro/tutorial03.txt:10
msgid "Overview"
msgstr "概况"

#: ../../intro/tutorial03.txt:12
msgid ""
"A view is a \"type\" of Web page in your Django application that "
"generally serves a specific function and has a specific template. For "
"example, in a blog application, you might have the following views:"
msgstr "Django 中的视图的概念是「一类具有相同功能和模板的网页的集合」。比如，在一个博客应用中，你可能会创建如下几个视图："

#: ../../intro/tutorial03.txt:16
msgid "Blog homepage -- displays the latest few entries."
msgstr "博客首页——展示最近的几项内容。"

#: ../../intro/tutorial03.txt:18
msgid "Entry \"detail\" page -- permalink page for a single entry."
msgstr "内容“详情”页——详细展示某项内容。"

#: ../../intro/tutorial03.txt:20
msgid ""
"Year-based archive page -- displays all months with entries in the given "
"year."
msgstr "以年为单位的归档页——展示选中的年份里各个月份创建的内容。"

#: ../../intro/tutorial03.txt:23
msgid ""
"Month-based archive page -- displays all days with entries in the given "
"month."
msgstr "以月为单位的归档页——展示选中的月份里各天创建的内容。"

#: ../../intro/tutorial03.txt:26
msgid "Day-based archive page -- displays all entries in the given day."
msgstr "以天为单位的归档页——展示选中天里创建的所有内容。"

#: ../../intro/tutorial03.txt:28
msgid "Comment action -- handles posting comments to a given entry."
msgstr "评论处理器——用于响应为一项内容添加评论的操作。"

#: ../../intro/tutorial03.txt:30
msgid "In our poll application, we'll have the following four views:"
msgstr "而在我们的投票应用中，我们需要下列几个视图："

#: ../../intro/tutorial03.txt:32
msgid "Question \"index\" page -- displays the latest few questions."
msgstr "问题索引页——展示最近的几个投票问题。"

#: ../../intro/tutorial03.txt:34
msgid ""
"Question \"detail\" page -- displays a question text, with no results but"
" with a form to vote."
msgstr "问题详情页——展示某个投票的问题和不带结果的选项列表。"

#: ../../intro/tutorial03.txt:37
msgid "Question \"results\" page -- displays results for a particular question."
msgstr "问题结果页——展示某个投票的结果。"

#: ../../intro/tutorial03.txt:39
msgid ""
"Vote action -- handles voting for a particular choice in a particular "
"question."
msgstr "投票处理器——用于响应用户为某个问题的特定选项投票的操作。"

#: ../../intro/tutorial03.txt:42
msgid ""
"In Django, web pages and other content are delivered by views. Each view "
"is represented by a simple Python function (or method, in the case of "
"class-based views). Django will choose a view by examining the URL that's"
" requested (to be precise, the part of the URL after the domain name)."
msgstr ""
"在 Django 中，网页和其他内容都是从视图派生而来。每一个视图表现为一个简单的 Python "
"函数(或者说方法，如果是在基于类的视图里的话)。Django 将会根据用户请求的 URL 来选择使用哪个视图(更准确的说，是根据 URL "
"中域名之后的部分)。"

#: ../../intro/tutorial03.txt:47
msgid ""
"Now in your time on the web you may have come across such beauties as "
"\"ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B\"."
" You will be pleased to know that Django allows us much more elegant *URL"
" patterns* than that."
msgstr ""
"在你上网的过程中，很可能看见过像这样美丽的 URL： "
"\"ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B\""
" 。别担心，Django 里的 *URL 规则* 要比这优雅的多！"

#: ../../intro/tutorial03.txt:52
msgid ""
"A URL pattern is simply the general form of a URL - for example: "
"``/newsarchive/<year>/<month>/``."
msgstr "一个 URL 模式定义了某种 URL 的基本格式——举个例子：``/newsarchive/<year>/<month>/``."

#: ../../intro/tutorial03.txt:55
msgid ""
"To get from a URL to a view, Django uses what are known as 'URLconfs'. A "
"URLconf maps URL patterns (described as regular expressions) to views."
msgstr ""
"为了将 URL 和视图关联起来，Django 使用了 'URLconfs' 来配置。URLconf 将 URL "
"模式(表现为一个正则表达式)映射到视图。"

#: ../../intro/tutorial03.txt:58
#, fuzzy
msgid ""
"This tutorial provides basic instruction in the use of URLconfs, and you "
"can refer to :mod:`django.urls` for more information."
msgstr "本教程只会介绍 URLconf 的基础内容，你可以看看 :mod:`django.core.urlresolvers` 以获取更多内容。"

#: ../../intro/tutorial03.txt:62
msgid "Writing more views"
msgstr "编写更多视图"

#: ../../intro/tutorial03.txt:64
msgid ""
"Now let's add a few more views to ``polls/views.py``. These views are "
"slightly different, because they take an argument:"
msgstr "现在让我们向 ``polls/views.py`` 里添加更多视图。这些视图有一些不同，因为他们接收参数："

#: ../../intro/tutorial03.txt:80
msgid ""
"Wire these new views into the ``polls.urls`` module by adding the "
"following :func:`~django.conf.urls.url` calls:"
msgstr ""
"把这些新视图添加进 ``polls.urls``  模块里，只要添加几个 :func:`~django.conf.urls.url`  "
"函数调用就行："

#: ../../intro/tutorial03.txt:101
msgid ""
"Take a look in your browser, at \"/polls/34/\". It'll run the "
"``detail()`` method and display whatever ID you provide in the URL. Try "
"\"/polls/34/results/\" and \"/polls/34/vote/\" too -- these will display "
"the placeholder results and voting pages."
msgstr ""
"然后看看你的浏览器，如果你转到  \"/polls/34/\" ，Django 将会运行 ``detail()`` 方法并且展示你在 URL "
"里提供的问题 ID。再试试 \"/polls/34/vote/\"  和 \"/polls/34/vote/\" "
"——你将会看到暂时用于占位的结果和投票页。"

#: ../../intro/tutorial03.txt:106
msgid ""
"When somebody requests a page from your website -- say, \"/polls/34/\", "
"Django will load the ``mysite.urls`` Python module because it's pointed "
"to by the :setting:`ROOT_URLCONF` setting. It finds the variable named "
"``urlpatterns`` and traverses the regular expressions in order. After "
"finding the match at ``'^polls/'``, it strips off the matching text "
"(``\"polls/\"``) and sends the remaining text -- ``\"34/\"`` -- to the "
"'polls.urls' URLconf for further processing. There it matches "
"``r'^(?P<question_id>[0-9]+)/$'``, resulting in a call to the "
"``detail()`` view like so::"
msgstr ""

#: ../../intro/tutorial03.txt:117
msgid ""
"The ``question_id='34'`` part comes from ``(?P<question_id>[0-9]+)``. "
"Using parentheses around a pattern \"captures\" the text matched by that "
"pattern and sends it as an argument to the view function; "
"``?P<question_id>`` defines the name that will be used to identify the "
"matched pattern; and ``[0-9]+`` is a regular expression to match a "
"sequence of digits (i.e., a number)."
msgstr ""
"  ``question_id='34'`` 这一部分是由( ``(?P<question_id>[0-9]+)`` "
")产生的。使用括号来包围一部分模式，就可以“ captures "
"捕获”这部分所匹配到的文本，随后作为参数被传递给视图函数；``?P<question_id>``  用于定义匹配部分的名字；``[0-9]+`` "
"是用于匹配一连串数字（也就是所有整数）的正则表达式。"

#: ../../intro/tutorial03.txt:123
msgid ""
"Because the URL patterns are regular expressions, there really is no "
"limit on what you can do with them. And there's no need to add URL cruft "
"such as ``.html`` -- unless you want to, in which case you can do "
"something like this::"
msgstr ""
"因为 URL 模式本质上是正则表达式，所以不会有规定限制你如何使用它。对了，为每个 URL 加上不必要的东西，例如 ``.html`` "
"，是没有必要的。不过如果你非要加的话，也是可以的："

#: ../../intro/tutorial03.txt:130
msgid "But, don't do that. It's silly."
msgstr "但是，别这样做，这太傻了。"

#: ../../intro/tutorial03.txt:133
msgid "Write views that actually do something"
msgstr "写一个真正有用的视图"

#: ../../intro/tutorial03.txt:135
msgid ""
"Each view is responsible for doing one of two things: returning an "
":class:`~django.http.HttpResponse` object containing the content for the "
"requested page, or raising an exception such as "
":exc:`~django.http.Http404`. The rest is up to you."
msgstr ""
"每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 :class:`~django.http.HttpResponse` "
"对象，或者抛出一个异常，比如 :exc:`~django.http.Http404` 。至于你还想干些什么，都随你。"

#: ../../intro/tutorial03.txt:140
msgid ""
"Your view can read records from a database, or not. It can use a template"
" system such as Django's -- or a third-party Python template system -- or"
" not. It can generate a PDF file, output XML, create a ZIP file on the "
"fly, anything you want, using whatever Python libraries you want."
msgstr ""
"你的视图可以从数据库里读取记录，可以使用一个模板引擎（比如 Django 自带的，或者其他第三方的），可以生成一个 PDF 文件，可以输出一个 "
"XML，创建一个 ZIP 文件，你可以做任何你想做的事，使用任何你想用的 Python 库。"

#: ../../intro/tutorial03.txt:145
msgid ""
"All Django wants is that :class:`~django.http.HttpResponse`. Or an "
"exception."
msgstr "Django只要求返回的是一个 :class:`~django.http.HttpResponse` 。 或者抛出一个异常。"

#: ../../intro/tutorial03.txt:147
msgid ""
"Because it's convenient, let's use Django's own database API, which we "
"covered in :doc:`Tutorial 2 </intro/tutorial02>`. Here's one stab at a "
"new ``index()`` view, which displays the latest 5 poll questions in the "
"system, separated by commas, according to publication date:"
msgstr ""
"因为 Django 自带的数据库 API 很方便 :doc:`Tutorial 2 </intro/tutorial02>` "
"，所以我们试试在视图里使用它。我们在 ``index()``  函数里插入了一些新内容，让它能展示数据库里以发布日期排序的最近5 "
"个投票问题，以空格分割："

#: ../../intro/tutorial03.txt:167
msgid ""
"There's a problem here, though: the page's design is hard-coded in the "
"view. If you want to change the way the page looks, you'll have to edit "
"this Python code. So let's use Django's template system to separate the "
"design from Python by creating a template that the view can use."
msgstr ""
"这里有个问题：页面的设计是硬编码在视图函数的代码里的。如果你想改变页面的样子，你需要编辑 Python 代码。所以让我们使用 Django "
"的模板系统，只要创建一个视图，就可以将页面的设计从代码中分离出来。"

#: ../../intro/tutorial03.txt:172
msgid ""
"First, create a directory called ``templates`` in your ``polls`` "
"directory. Django will look for templates in there."
msgstr "首先，在你的 ``polls`` 目录里创建一个 ``templates`` 目录。Django 将会在这个目录里查找模板文件。"

#: ../../intro/tutorial03.txt:175
msgid ""
"Your project's :setting:`TEMPLATES` setting describes how Django will "
"load and render templates. The default settings file configures a "
"``DjangoTemplates`` backend whose :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>` option is set to ``True``. By convention ``DjangoTemplates`` "
"looks for a \"templates\" subdirectory in each of the "
":setting:`INSTALLED_APPS`."
msgstr ""
"你项目的 :setting:`TEMPLATES` 配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 "
"`DjangoTemplates`` 后端，并将  :setting:`APP_DIRS <TEMPLATES-APP_DIRS>`  设置成了 "
"True。这一选项将会让 ``DjangoTemplates``  在每个 :setting:`INSTALLED_APPS`  文件夹中寻找 "
"\"templates\" 子目录。这就是为什么尽管我们没有像在第二部分中那样修改 DIRS 设置，Django 也能正确找到 polls "
"的模板位置的原因。"

#: ../../intro/tutorial03.txt:181
msgid ""
"Within the ``templates`` directory you have just created, create another "
"directory called ``polls``, and within that create a file called "
"``index.html``. In other words, your template should be at "
"``polls/templates/polls/index.html``. Because of how the "
"``app_directories`` template loader works as described above, you can "
"refer to this template within Django simply as ``polls/index.html``."
msgstr ""
"在你刚刚创建的 ``templates`` 目录里，再创建一个目录 polls，然后在其中新建一个文件 ``index.html`` "
"。换句话说，你的模板文件的路径应该是  ``polls/templates/polls/index.html`` 。因为 Django "
"会寻找到对应的 ``app_directories`` ，所以你只需要使用 ``polls/index.html``  就可以引用到这一模板了。"

#: ../../intro/tutorial03.txt:188
msgid "Template namespacing"
msgstr "模板命名空间"

#: ../../intro/tutorial03.txt:190
msgid ""
"Now we *might* be able to get away with putting our templates directly in"
" ``polls/templates`` (rather than creating another ``polls`` "
"subdirectory), but it would actually be a bad idea. Django will choose "
"the first template it finds whose name matches, and if you had a template"
" with the same name in a *different* application, Django would be unable "
"to distinguish between them. We need to be able to point Django at the "
"right one, and the easiest way to ensure this is by *namespacing* them. "
"That is, by putting those templates inside *another* directory named for "
"the application itself."
msgstr ""
"虽然我们现在可以将模板文件直接放在  ``polls/templates`` 文件夹中(而不是再建立一个 ``polls`` "
"子文件夹)，但是这样做不太好。Django 将会选择第一个匹配的模板文件，如果你有一个模板文件正好和另一个应用中的某个模板文件重名，Django "
"没有办法 *different 区分* 它们。我们需要帮助 Django 选择正确的模板，最简单的方法就是把他们放入各自的 "
"*namespacing命名空间*  中，也就是把这些模板放入一个和 *another 自身* 应用重名的子文件夹里。"

#: ../../intro/tutorial03.txt:199
msgid "Put the following code in that template:"
msgstr "将下面的代码输入到刚刚创建的模板文件中："

#: ../../intro/tutorial03.txt:214
msgid ""
"Now let's update our ``index`` view in ``polls/views.py`` to use the "
"template:"
msgstr "然后，让我们更新一下 ``index`` view in ``polls/views.py``  里的 ``index`` 视图："

#: ../../intro/tutorial03.txt:233
msgid ""
"That code loads the template called  ``polls/index.html`` and passes it a"
" context. The context is a dictionary mapping template variable names to "
"Python objects."
msgstr ""
"上述代码的作用是，载入 ``polls/index.html``  "
"模板文件，并且向它传递一个上下文环境context。这个上下文是一个字典，它将模板内的变量映射为 Python 对象。"

#: ../../intro/tutorial03.txt:237
msgid ""
"Load the page by pointing your browser at \"/polls/\", and you should see"
" a bulleted-list containing the \"What's up\" question from "
":doc:`Tutorial 2 </intro/tutorial02>`. The link points to the question's "
"detail page."
msgstr ""
"用你的浏览器访问 \"/polls/\" ，你将会看见一个无序列表，列出了我们在  :doc:`教程第二部分 "
"</intro/tutorial02>`. 以中添加的 “What's up” 投票问题，它链接到这个投票的详情页。"

#: ../../intro/tutorial03.txt:242
msgid "A shortcut: :func:`~django.shortcuts.render`"
msgstr "一个快捷函数:  :func:`~django.shortcuts.render`"

#: ../../intro/tutorial03.txt:244
msgid ""
"It's a very common idiom to load a template, fill a context and return an"
" :class:`~django.http.HttpResponse` object with the result of the "
"rendered template. Django provides a shortcut. Here's the full "
"``index()`` view, rewritten:"
msgstr ""
"「载入模板，填充上下文，再返回由它生成的 :class:`~django.http.HttpResponse`  "
"对象」是一个如此常用的操作流程。于是 Django 提供了一个快捷函数，我们用它来重写  ``index()``  视图："

#: ../../intro/tutorial03.txt:262
msgid ""
"Note that once we've done this in all these views, we no longer need to "
"import :mod:`~django.template.loader` and "
":class:`~django.http.HttpResponse` (you'll want to keep ``HttpResponse`` "
"if you still have the stub methods for ``detail``, ``results``, and "
"``vote``)."
msgstr ""
"注意到，我们不再需要导入 :mod:`~django.template.loader`  和 "
":class:`~django.http.HttpResponse` 。不过如果你还有其他函数(比如说 ``detail``, "
"``results``, 和 ``vote`` )需要用到它的话，就需要保持  ``HttpResponse``   的导入。"

#: ../../intro/tutorial03.txt:267
msgid ""
"The :func:`~django.shortcuts.render` function takes the request object as"
" its first argument, a template name as its second argument and a "
"dictionary as its optional third argument. It returns an "
":class:`~django.http.HttpResponse` object of the given template rendered "
"with the given context."
msgstr ""
" :func:`~django.shortcuts.render`  函数的第一个参数是一个请求 "
":class:`~django.http.HttpResponse` "
"对象，第二个参数是需要载入的模板的名字。第三个参数是需要用于渲染模板的上下文字典，这个参数是可选的。函数返回一个 "
":class:`~django.http.HttpResponse`  对象，内容为指定模板用指定上下文渲染后的结果。"

#: ../../intro/tutorial03.txt:273
msgid "Raising a 404 error"
msgstr "抛出 404 错误"

#: ../../intro/tutorial03.txt:275
msgid ""
"Now, let's tackle the question detail view -- the page that displays the "
"question text for a given poll. Here's the view:"
msgstr "现在，我们来处理投票详情视图——它会显示指定投票的问题标题。下面是这个视图的代码："

#: ../../intro/tutorial03.txt:293
msgid ""
"The new concept here: The view raises the :exc:`~django.http.Http404` "
"exception if a question with the requested ID doesn't exist."
msgstr "这里有个新东西。如果指定问题 ID 所对应的问题不存在，这个视图就会抛出一个 :exc:`~django.http.Http404` 异常。"

#: ../../intro/tutorial03.txt:296
msgid ""
"We'll discuss what you could put in that ``polls/detail.html`` template a"
" bit later, but if you'd like to quickly get the above example working, a"
" file containing just:"
msgstr ""
"我们稍后再讨论你需要在 ``polls/detail.html``  "
"里输入什么，但是如果你想试试上面这段代码是否正常工作的话，你可以暂时把下面这段输进去："

#: ../../intro/tutorial03.txt:305
msgid "will get you started for now."
msgstr "这样你就能测试了。"

#: ../../intro/tutorial03.txt:308
msgid "A shortcut: :func:`~django.shortcuts.get_object_or_404`"
msgstr "一个快捷函数: :func:`~django.shortcuts.get_object_or_404` "

#: ../../intro/tutorial03.txt:310
msgid ""
"It's a very common idiom to use "
":meth:`~django.db.models.query.QuerySet.get` and raise "
":exc:`~django.http.Http404` if the object doesn't exist. Django provides "
"a shortcut. Here's the ``detail()`` view, rewritten:"
msgstr ""
"尝试用 :meth:`~django.db.models.query.QuerySet.get`  函数获取一个对象，如果不存在就抛出 "
":exc:`~django.http.Http404` 错误也是一个普遍的流程。Django 也提供了一个快捷函数，下面是修改后的详情 "
"``detail()`` 视图代码："

#: ../../intro/tutorial03.txt:325
msgid ""
"The :func:`~django.shortcuts.get_object_or_404` function takes a Django "
"model as its first argument and an arbitrary number of keyword arguments,"
" which it passes to the :meth:`~django.db.models.query.QuerySet.get` "
"function of the model's manager. It raises :exc:`~django.http.Http404` if"
" the object doesn't exist."
msgstr ""
" :func:`~django.shortcuts.get_object_or_404`  函数的第一个参数是一个 Django "
"模型。在此之后可以有任意数量的关键字参数，他们会被直接传递给模型的 "
":meth:`~django.db.models.query.QuerySet.get` 函数。如果符合要求的对象不存在，此快捷函数将会抛出一个 "
":exc:`~django.http.Http404`  异常。"

#: ../../intro/tutorial03.txt:333
msgid ""
"Why do we use a helper function "
":func:`~django.shortcuts.get_object_or_404` instead of automatically "
"catching the :exc:`~django.core.exceptions.ObjectDoesNotExist` exceptions"
" at a higher level, or having the model API raise "
":exc:`~django.http.Http404` instead of "
":exc:`~django.core.exceptions.ObjectDoesNotExist`?"
msgstr ""
"为什么我们使用辅助函数 :func:`~django.shortcuts.get_object_or_404` 而不是自己捕获 "
":exc:`~django.core.exceptions.ObjectDoesNotExist` 异常呢？还有，为什么模型 API 不直接抛出 "
":exc:`~django.http.Http404`  而是抛出 "
":exc:`~django.core.exceptions.ObjectDoesNotExist` 呢？"

#: ../../intro/tutorial03.txt:339
msgid ""
"Because that would couple the model layer to the view layer. One of the "
"foremost design goals of Django is to maintain loose coupling. Some "
"controlled coupling is introduced in the :mod:`django.shortcuts` module."
msgstr ""
"因为这样做会增加模型层和视图层的耦合性。指导 Django 设计的最重要的思想之一就是要保证松散耦合。一些受控的耦合将会被包含在  "
":mod:`django.shortcuts` 模块中。"

#: ../../intro/tutorial03.txt:343
msgid ""
"There's also a :func:`~django.shortcuts.get_list_or_404` function, which "
"works just as :func:`~django.shortcuts.get_object_or_404` -- except using"
" :meth:`~django.db.models.query.QuerySet.filter` instead of "
":meth:`~django.db.models.query.QuerySet.get`. It raises "
":exc:`~django.http.Http404` if the list is empty."
msgstr ""
"也有 :func:`~django.shortcuts.get_list_or_404` 函数，工作原理和 "
":func:`~django.shortcuts.get_object_or_404` 一样，除了 "
":meth:`~django.db.models.query.QuerySet.get` 函数被换成了 "
":meth:`~django.db.models.query.QuerySet.filter` 函数。如果列表为空的话会抛出 "
":exc:`~django.http.Http404` 异常。"

#: ../../intro/tutorial03.txt:350
msgid "Use the template system"
msgstr "使用模板系统"

#: ../../intro/tutorial03.txt:352
msgid ""
"Back to the ``detail()`` view for our poll application. Given the context"
" variable ``question``, here's what the ``polls/detail.html`` template "
"might look like:"
msgstr ""
"回过头去看看我们的 ``detail()`` 视图。它向模板传递了上下文变量 ``question`` 。下面是 "
"``polls/detail.html`` 模板里正式的代码："

#: ../../intro/tutorial03.txt:366
msgid ""
"The template system uses dot-lookup syntax to access variable attributes."
" In the example of ``{{ question.question_text }}``, first Django does a "
"dictionary lookup on the object ``question``. Failing that, it tries an "
"attribute lookup -- which works, in this case. If attribute lookup had "
"failed, it would've tried a list-index lookup."
msgstr ""
"模板系统统一使用点符号来访问变量的属性。在示例 ``{{ question.question_text }}`` 中，首先 Django 尝试对"
"  ``question`` "
"对象使用字典查找(也就是使用obj.get(str)操作)，如果失败了就尝试属性查找(也就是obj.str操作)，结果是成功了。如果这一操作也失败的话，将会尝试列表查找(也就是obj[int]操作)。"

#: ../../intro/tutorial03.txt:372
#, python-format
msgid ""
"Method-calling happens in the :ttag:`{% for %}<for>` loop: "
"``question.choice_set.all`` is interpreted as the Python code "
"``question.choice_set.all()``, which returns an iterable of ``Choice`` "
"objects and is suitable for use in the :ttag:`{% for %}<for>` tag."
msgstr ""
"在 :ttag:`{% for %}<for>`  循环中发生的函数调用：``question.choice_set.all`` 被解释为 "
"Python 代码 ``question.choice_set.all()`` ，将会返回一个可迭代的 ``Choice`` 对象，这一对象可以在"
" :ttag:`{% for %}<for>`  标签内部使用。"

#: ../../intro/tutorial03.txt:377
msgid ""
"See the :doc:`template guide </topics/templates>` for more about "
"templates."
msgstr "查看 :doc:`模板指南 </topics/templates>` 可以了解关于模板的更多信息。"

#: ../../intro/tutorial03.txt:380
msgid "Removing hardcoded URLs in templates"
msgstr "去除模板中的硬编码 URL"

#: ../../intro/tutorial03.txt:382
msgid ""
"Remember, when we wrote the link to a question in the "
"``polls/index.html`` template, the link was partially hardcoded like "
"this:"
msgstr "还记得吗，我们在 ``polls/index.html`` 里编写投票链接时，链接是硬编码的："

#: ../../intro/tutorial03.txt:389
#, python-format
msgid ""
"The problem with this hardcoded, tightly-coupled approach is that it "
"becomes challenging to change URLs on projects with a lot of templates. "
"However, since you defined the name argument in the "
":func:`~django.conf.urls.url` functions in the ``polls.urls`` module, you"
" can remove a reliance on specific URL paths defined in your url "
"configurations by using the ``{% url %}`` template tag:"
msgstr ""
"问题在于，硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。然而，因为你在 ``polls.urls`` 的 "
":func:`~django.conf.urls.url` 函数中通过 name 参数为 URL 定义了名字，你可以使用  ``{% url "
"%}`` 标签代替它："

#: ../../intro/tutorial03.txt:399
msgid ""
"The way this works is by looking up the URL definition as specified in "
"the ``polls.urls`` module. You can see exactly where the URL name of "
"'detail' is defined below::"
msgstr ""
"这个标签的工作方式是在 ``polls.urls`` 模块的 URL 定义中寻具有指定名字的条目。你可以回忆一下，具有名字 'detail'  的"
" URL 是在如下语句中定义的："

#: ../../intro/tutorial03.txt:408
msgid ""
"If you want to change the URL of the polls detail view to something else,"
" perhaps to something like ``polls/specifics/12/`` instead of doing it in"
" the template (or templates) you would change it in ``polls/urls.py``::"
msgstr ""
"如果你想改变投票详情视图的 URL，比如想改成 ``polls/specifics/12/`` ，你不用在模板里修改任何东西( 其它模板)，只要在"
" ``polls/urls.py`` 里稍微修改一下就行："

#: ../../intro/tutorial03.txt:418
msgid "Namespacing URL names"
msgstr "为 URL 名称添加命名空间"

#: ../../intro/tutorial03.txt:420
#, python-format
msgid ""
"The tutorial project has just one app, ``polls``. In real Django "
"projects, there might be five, ten, twenty apps or more. How does Django "
"differentiate the URL names between them? For example, the ``polls`` app "
"has a ``detail`` view, and so might an app on the same project that is "
"for a blog. How does one make it so that Django knows which app view to "
"create for a url when using the ``{% url %}`` template tag?"
msgstr ""
"教程项目只有一个应用，``polls`` 。在一个真实的 Django 项目中，可能会有五个，十个，二十个甚至更多应用。Django "
"如何分辨重名的 URL 呢？举个例子，``polls``  应用有 ``detail` 视图，可能另一个博客应用也有同名的视图。Django "
"如何知道 ``{% url %}`` 标签到底对应哪一个应用的 URL 呢？"

#: ../../intro/tutorial03.txt:427
msgid ""
"The answer is to add namespaces to your  URLconf. In the "
"``polls/urls.py`` file, go ahead and add an ``app_name`` to set the "
"application namespace:"
msgstr "答案是：在根 URLconf 中添加命名空间。在 ``polls/urls.py`` 文件中稍作修改，加上 ``app_name` 命名空间："

#: ../../intro/tutorial03.txt:445
msgid "Now change your ``polls/index.html`` template from:"
msgstr "现在，编辑 ``polls/index.html`` 文件，从："

#: ../../intro/tutorial03.txt:452
msgid "to point at the namespaced detail view:"
msgstr "修改为指向具有命名空间的详细视图："

#: ../../intro/tutorial03.txt:459
msgid ""
"When you're comfortable with writing views, read :doc:`part 4 of this "
"tutorial </intro/tutorial04>` to learn about simple form processing and "
"generic views."
msgstr "当你对你写的视图感到满意后，请阅读 :doc:`教程的第4部分 </intro/tutorial04>` 来了解简单的表单处理和通用视图。"

#: ../../intro/tutorial04.txt:3
msgid "Writing your first Django app, part 4"
msgstr "编写你的第一个Django应用，第4部分"

#: ../../intro/tutorial04.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 3 </intro/tutorial03>` left "
"off. We're continuing the Web-poll application and will focus on simple "
"form processing and cutting down our code."
msgstr ""
"这一篇从 :doc:`Tutorial 3 </intro/tutorial03>`  "
"结尾的地方继续讲起。我们将继续编写投票应用，专注于简单的表单处理并且精简我们的代码。"

#: ../../intro/tutorial04.txt:10
msgid "Write a simple form"
msgstr "编写一个简单的表单"

#: ../../intro/tutorial04.txt:12
msgid ""
"Let's update our poll detail template (\"polls/detail.html\") from the "
"last tutorial, so that the template contains an HTML ``<form>`` element:"
msgstr ""
"让我们更新一下在上一个教程中编写的投票详细页面的模板  (\"polls/detail.html\") ，让它包含一个 HTML "
"``<form>`` 元素："

#: ../../intro/tutorial04.txt:31
msgid "A quick rundown:"
msgstr "简要说明："

#: ../../intro/tutorial04.txt:33
msgid ""
"The above template displays a radio button for each question choice. The "
"``value`` of each radio button is the associated question choice's ID. "
"The ``name`` of each radio button is ``\"choice\"``. That means, when "
"somebody selects one of the radio buttons and submits the form, it'll "
"send the POST data ``choice=#`` where # is the ID of the selected choice."
" This is the basic concept of HTML forms."
msgstr ""
"上面的模板在 Question 的每个 Choice 前添加一个单选按钮。 每个单选按钮的 ``value`` 属性是对应的各个 Choice 的"
" ID。每个单选按钮的 ``name`` 是 ``\"choice\"`` 。这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个 "
"POST 数据 ``choice=#`` ，其中# 为选择的 Choice 的 ID。这是 HTML 表单的基本概念。"

#: ../../intro/tutorial04.txt:40
#, python-format
msgid ""
"We set the form's ``action`` to ``{% url 'polls:vote' question.id %}``, "
"and we set ``method=\"post\"``. Using ``method=\"post\"`` (as opposed to "
"``method=\"get\"``) is very important, because the act of submitting this"
" form will alter data server-side. Whenever you create a form that alters"
" data server-side, use ``method=\"post\"``. This tip isn't specific to "
"Django; it's just good Web development practice."
msgstr ""
"我们设置表单的 ``action`` 为 ``{% url 'polls:vote' question.id %}`` ，并设置  "
"``method=\"post\"`` 。使用 ``method=\"post\"``(与其相对的是 "
"``method=\"get\"``)是非常重要的，因为这个提交表单的行为会改变服务器端的数据。 "
"无论何时，当你需要创建一个改变服务器端数据的表单时，请使用 ``method=\"post\"`` 。这不是 Django "
"的特定技巧；这是优秀的网站开发实践。"

#: ../../intro/tutorial04.txt:47
msgid ""
"``forloop.counter`` indicates how many times the :ttag:`for` tag has gone"
" through its loop"
msgstr "``forloop.counter`` 指示 :ttag:`for` 标签已经循环多少次。"

#: ../../intro/tutorial04.txt:50
#, python-format
msgid ""
"Since we're creating a POST form (which can have the effect of modifying "
"data), we need to worry about Cross Site Request Forgeries. Thankfully, "
"you don't have to worry too hard, because Django comes with a very easy-"
"to-use system for protecting against it. In short, all POST forms that "
"are targeted at internal URLs should use the :ttag:`{% csrf_token "
"%}<csrf_token>` template tag."
msgstr ""
"由于我们创建一个 POST 表单(它具有修改数据的作用)，所以我们需要小心跨站点请求伪造。 谢天谢地，你不必太过担心，因为 Django "
"已经拥有一个用来防御它的非常容易使用的系统。 简而言之，所有针对内部 URL 的 POST 表单都应该使用  :ttag:`{% "
"csrf_token %}<csrf_token>` 模板标签。"

#: ../../intro/tutorial04.txt:57
msgid ""
"Now, let's create a Django view that handles the submitted data and does "
"something with it. Remember, in :doc:`Tutorial 3 </intro/tutorial03>`, we"
" created a URLconf for the polls application that includes this line:"
msgstr ""
"现在，让我们来创建一个 Django 视图来处理提交的数据。记住，在 :doc:`教程第3部分 </intro/tutorial03>` "
"中，我们为投票应用创建了一个 URLconf ，包含这一行："

#: ../../intro/tutorial04.txt:66
msgid ""
"We also created a dummy implementation of the ``vote()`` function. Let's "
"create a real version. Add the following to ``polls/views.py``:"
msgstr "我们还创建了一个 ``vote()`` 函数的虚拟实现。让我们来创建一个真实的版本。 将下面的代码添加到 ``polls/views.py`` ："

#: ../../intro/tutorial04.txt:96
msgid "This code includes a few things we haven't covered yet in this tutorial:"
msgstr "以上代码中有些内容还未在本教程中提到过："

#: ../../intro/tutorial04.txt:98
msgid ""
":attr:`request.POST <django.http.HttpRequest.POST>` is a dictionary-like "
"object that lets you access submitted data by key name. In this case, "
"``request.POST['choice']`` returns the ID of the selected choice, as a "
"string. :attr:`request.POST <django.http.HttpRequest.POST>` values are "
"always strings."
msgstr ""
":attr:`request.POST <django.http.HttpRequest.POST>`  "
"是一个类字典对象，让你可以通过关键字的名字获取提交的数据。 这个例子中， ``request.POST['choice']`` "
"以字符串形式返回选择的 Choice 的 ID。 :attr:`request.POST "
"<django.http.HttpRequest.POST>`  的值永远是字符串。"

#: ../../intro/tutorial04.txt:104
msgid ""
"Note that Django also provides :attr:`request.GET "
"<django.http.HttpRequest.GET>` for accessing GET data in the same way -- "
"but we're explicitly using :attr:`request.POST "
"<django.http.HttpRequest.POST>` in our code, to ensure that data is only "
"altered via a POST call."
msgstr ""
"注意，Django 还以同样的方式提供 :attr:`request.GET <django.http.HttpRequest.GET>`  "
"用于访问 GET 数据 —— 但我们在代码中显式地使用 :attr:`request.POST "
"<django.http.HttpRequest.POST>`  ，以保证数据只能通过POST调用改动。"

#: ../../intro/tutorial04.txt:110
msgid ""
"``request.POST['choice']`` will raise :exc:`KeyError` if ``choice`` "
"wasn't provided in POST data. The above code checks for :exc:`KeyError` "
"and redisplays the question form with an error message if ``choice`` "
"isn't given."
msgstr ""
"如果在 ``request.POST['choice']``  数据中没有提供 ``choice`` ， POST 将引发一个 "
":exc:`KeyError` 。上面的代码检查 :exc:`KeyError` ，如果没有给出 ``choice`` "
"将重新显示Question表单和一个错误信息。"

#: ../../intro/tutorial04.txt:115
msgid ""
"After incrementing the choice count, the code returns an "
":class:`~django.http.HttpResponseRedirect` rather than a normal "
":class:`~django.http.HttpResponse`. "
":class:`~django.http.HttpResponseRedirect` takes a single argument: the "
"URL to which the user will be redirected (see the following point for how"
" we construct the URL in this case)."
msgstr ""
"在增加Choice的得票数之后，代码返回一个 :class:`~django.http.HttpResponseRedirect` 而不是常用的 "
":class:`~django.http.HttpResponse`  、 "
":class:`~django.http.HttpResponseRedirect`  只接收一个参数：用户将要被重定向的 "
"URL(请继续看下去，我们将会解释如何构造这个例子中的 URL)。"

#: ../../intro/tutorial04.txt:122
msgid ""
"As the Python comment above points out, you should always return an "
":class:`~django.http.HttpResponseRedirect` after successfully dealing "
"with POST data. This tip isn't specific to Django; it's just good Web "
"development practice."
msgstr ""
" 正如上面的Python注释指出的，你应该在成功处理 POST 数据后总是返回一个 "
":class:`~django.http.HttpResponseRedirect` 。 这不是 Django "
"的特定技巧；这是那些优秀网站在开发实践中形成的共识。"

#: ../../intro/tutorial04.txt:127
#, fuzzy
msgid ""
"We are using the :func:`~django.urls.reverse` function in the "
":class:`~django.http.HttpResponseRedirect` constructor in this example. "
"This function helps avoid having to hardcode a URL in the view function. "
"It is given the name of the view that we want to pass control to and the "
"variable portion of the URL pattern that points to that view. In this "
"case, using the URLconf we set up in :doc:`Tutorial 3 "
"</intro/tutorial03>`, this :func:`~django.urls.reverse` call will return "
"a string like ::"
msgstr ""
"在这个例子中，我们在 :class:`~django.http.HttpResponseRedirect` 的构造函数中使用 "
":func:`~django.core.urlresolvers.reverse` 函数。这个函数避免了我们在视图函数中硬编码 "
"URL。它需要我们给出我们想要跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。 在本例中，使用在 :doc:`教程第三部分 "
"</intro/tutorial03>` 中设定的URLconf， "
":func:`~django.core.urlresolvers.reverse` 调用将返回一个这样的字符串："

#: ../../intro/tutorial04.txt:138
msgid ""
"where the ``3`` is the value of ``question.id``. This redirected URL will"
" then call the ``'results'`` view to display the final page."
msgstr "其中 ``3`` 是 ``question.id`` 的值。重定向的 URL 将调用 ``'results'`` 视图来显示最终的页面。"

#: ../../intro/tutorial04.txt:141
msgid ""
"As mentioned in :doc:`Tutorial 3 </intro/tutorial03>`, ``request`` is an "
":class:`~django.http.HttpRequest` object. For more on "
":class:`~django.http.HttpRequest` objects, see the :doc:`request and "
"response documentation </ref/request-response>`."
msgstr ""
"正如在 :doc:`教程第三部分 </intro/tutorial03>` "
"中提到的，:class:`~django.http.HttpRequest` 是一个 "
":class:`~django.http.HttpRequest` 对象。更多关于 "
":class:`~django.http.HttpRequest` 对象的内容，请参见  :doc:` 请求和响应的文档 </ref"
"/request-response>` 。"

#: ../../intro/tutorial04.txt:146
msgid ""
"After somebody votes in a question, the ``vote()`` view redirects to the "
"results page for the question. Let's write that view:"
msgstr "当有人对 Question 进行投票后，  ``vote()`` 视图将请求重定向到 Question 的结果界面。让我们来编写这个视图："

#: ../../intro/tutorial04.txt:159
msgid ""
"This is almost exactly the same as the ``detail()`` view from "
":doc:`Tutorial 3 </intro/tutorial03>`. The only difference is the "
"template name. We'll fix this redundancy later."
msgstr ""
"这和 :doc:`教程第3部分 </intro/tutorial03>` 中的  ``detail()`` "
"视图几乎一模一样。唯一的不同是模板的名字。 我们将在稍后解决这个冗余问题。"

#: ../../intro/tutorial04.txt:163
msgid "Now, create a ``polls/results.html`` template:"
msgstr "现在，创建一个 ``polls/results.html``  模板："

#: ../../intro/tutorial04.txt:178
msgid ""
"Now, go to ``/polls/1/`` in your browser and vote in the question. You "
"should see a results page that gets updated each time you vote. If you "
"submit the form without having chosen a choice, you should see the error "
"message."
msgstr ""
"现在，在你的浏览器中访问 ``/polls/1/`` 然后为 Question 投票。你应该看到一个投票结果页面，并且在你每次投票之后都会更新。 "
"如果你提交时没有选择任何Choice，你应该看到错误信息。"

#: ../../intro/tutorial04.txt:183
msgid ""
"The code for our ``vote()`` view does have a small problem. It first gets"
" the ``selected_choice`` object from the database, then computes the new "
"value of ``votes``, and then saves it back to the database. If two users "
"of your website try to vote at *exactly the same time*, this might go "
"wrong: The same value, let's say 42, will be retrieved for ``votes``. "
"Then, for both users the new value of 43 is computed and saved, but 44 "
"would be the expected value."
msgstr ""

#: ../../intro/tutorial04.txt:191
msgid ""
"This is called a *race condition*. If you are interested, you can read "
":ref:`avoiding-race-conditions-using-f` to learn how you can solve this "
"issue."
msgstr ""

#: ../../intro/tutorial04.txt:196
msgid "Use generic views: Less code is better"
msgstr "使用通用视图：代码还是少点好"

#: ../../intro/tutorial04.txt:198
msgid ""
"The ``detail()`` (from :doc:`Tutorial 3 </intro/tutorial03>`) and "
"``results()`` views are very simple -- and, as mentioned above, "
"redundant. The ``index()`` view, which displays a list of polls, is "
"similar."
msgstr ""
"``detail()``  (在 :doc:`教程第3部分 </intro/tutorial03>` 中)和 ``results()`` "
"视图都很简单 —— 并且，像上面提到的那样，存在冗余问题。用来显示一个议题列表的 ``index()``  视图（也在 :doc:`教程第3部分 "
"</intro/tutorial03>` 中）和它们类似。"

#: ../../intro/tutorial04.txt:202
msgid ""
"These views represent a common case of basic Web development: getting "
"data from the database according to a parameter passed in the URL, "
"loading a template and returning the rendered template. Because this is "
"so common, Django provides a shortcut, called the \"generic views\" "
"system."
msgstr ""
"这些视图反映基本的 Web 开发中的一个常见情况：根据 URL 中的参数从数据库中获取数据、载入模板文件然后返回渲染后的模板。 "
"由于这种情况特别常见，Django 提供一种快捷方式，叫做“通用视图”系统。"

#: ../../intro/tutorial04.txt:207
msgid ""
"Generic views abstract common patterns to the point where you don't even "
"need to write Python code to write an app."
msgstr "通用视图将常见的模式抽象化，可以使你在编写应用时甚至不需要编写Python代码。"

#: ../../intro/tutorial04.txt:210
msgid ""
"Let's convert our poll app to use the generic views system, so we can "
"delete a bunch of our own code. We'll just have to take a few steps to "
"make the conversion. We will:"
msgstr "让我们将我们的投票应用转换成使用通用视图系统，这样我们可以删除许多我们的代码。我们仅仅需要做以下几步来完成转换： 我们将："

#: ../../intro/tutorial04.txt:214
msgid "Convert the URLconf."
msgstr "转换 URLconf。"

#: ../../intro/tutorial04.txt:216
msgid "Delete some of the old, unneeded views."
msgstr "删除一些旧的、不再需要的代码。"

#: ../../intro/tutorial04.txt:218
msgid "Introduce new views based on Django's generic views."
msgstr "引进基于 Django 通用视图的新视图。"

#: ../../intro/tutorial04.txt:220
msgid "Read on for details."
msgstr "请继续阅读来了解详细信息。"

#: ../../intro/tutorial04.txt:222
msgid "Why the code-shuffle?"
msgstr "为什么要重构代码？"

#: ../../intro/tutorial04.txt:224
msgid ""
"Generally, when writing a Django app, you'll evaluate whether generic "
"views are a good fit for your problem, and you'll use them from the "
"beginning, rather than refactoring your code halfway through. But this "
"tutorial intentionally has focused on writing the views \"the hard way\" "
"until now, to focus on core concepts."
msgstr ""
"一般来说，当编写一个 Django "
"应用时，你应该先评估一下通用视图是否可以解决你的问题，你应该在一开始使用它，而不是进行到一半时重构代码。本教程目前为止是有意将重点放在以“艰难的方式”编写视图，这是为将重点放在核心概念上。"

#: ../../intro/tutorial04.txt:230
msgid "You should know basic math before you start using a calculator."
msgstr "就像在使用计算器之前你需要知道基本的数学一样。"

#: ../../intro/tutorial04.txt:233
msgid "Amend URLconf"
msgstr "改良 URLconf"

#: ../../intro/tutorial04.txt:235
msgid "First, open the ``polls/urls.py`` URLconf and change it like so:"
msgstr "首先，打开 ``polls/urls.py`` 这个 URLconf 并将它修改成："

#: ../../intro/tutorial04.txt:252
msgid ""
"Note that the name of the matched pattern in the regexes of the second "
"and third patterns has changed from ``<question_id>`` to ``<pk>``."
msgstr "注意在第二个和第三个模式的正则表达式中，匹配的模式的名字由  ``<question_id>`` 变成 ``<pk>`` 。"

#: ../../intro/tutorial04.txt:256
msgid "Amend views"
msgstr "改良视图"

#: ../../intro/tutorial04.txt:258
msgid ""
"Next, we're going to remove our old ``index``, ``detail``, and "
"``results`` views and use Django's generic views instead. To do so, open "
"the ``polls/views.py`` file and change it like so:"
msgstr ""
"下一步，我们将删除旧的 ``index``, ``detail``, 和 ``results`` 视图，并用 Django 的通用视图代替。打开 "
"``polls/views.py`` 文件，并将它修改成："

#: ../../intro/tutorial04.txt:295
msgid ""
"We're using two generic views here: "
":class:`~django.views.generic.list.ListView` and "
":class:`~django.views.generic.detail.DetailView`. Respectively, those two"
" views abstract the concepts of \"display a list of objects\" and "
"\"display a detail page for a particular type of object.\""
msgstr ""
"我们在这里使用两个通用视图： :class:`~django.views.generic.list.ListView` 和 "
":class:`~django.views.generic.detail.DetailView` "
"。这两个视图分别抽象“显示一个对象列表”和“显示一个特定类型对象的详细信息页面”这两种概念。"

#: ../../intro/tutorial04.txt:301
msgid ""
"Each generic view needs to know what model it will be acting upon. This "
"is provided using the ``model`` attribute."
msgstr "每个通用视图需要知道它将作用于哪个模型。 这由 ``model`` 属性提供。"

#: ../../intro/tutorial04.txt:304
msgid ""
"The :class:`~django.views.generic.detail.DetailView` generic view expects"
" the primary key value captured from the URL to be called ``\"pk\"``, so "
"we've changed ``question_id`` to ``pk`` for the generic views."
msgstr ""
":class:`~django.views.generic.detail.DetailView`  期望从 URL 中捕获名为   "
"``\"pk\"`` 的主键值，所以我们为通用视图把 ``question_id`` 改成 ``pk`` 。"

#: ../../intro/tutorial04.txt:309
msgid ""
"By default, the :class:`~django.views.generic.detail.DetailView` generic "
"view uses a template called ``<app name>/<model name>_detail.html``. In "
"our case, it would use the template ``\"polls/question_detail.html\"``. "
"The ``template_name`` attribute is used to tell Django to use a specific "
"template name instead of the autogenerated default template name. We also"
" specify the ``template_name`` for the ``results`` list view -- this "
"ensures that the results view and the detail view have a different "
"appearance when rendered, even though they're both a "
":class:`~django.views.generic.detail.DetailView` behind the scenes."
msgstr ""
"默认情况下，通用视图 :class:`~django.views.generic.detail.DetailView` 使用一个叫做 ``<app"
" name>/<model name>_detail.html`` 的模板。在我们的例子中，它将使用 "
"``\"polls/question_detail.html\"`` 模板。``template_name`` "
"属性是用来告诉Django使用一个指定的模板名字，而不是自动生成的默认名字。 我们也为 ``results`` 列表视图指定了 "
"``template_name``  —— 这确保results视图和detail视图在渲染时具有不同的外观，即使它们在后台都是同一个 "
":class:`~django.views.generic.detail.DetailView` 。"

#: ../../intro/tutorial04.txt:319
msgid ""
"Similarly, the :class:`~django.views.generic.list.ListView` generic view "
"uses a default template called ``<app name>/<model name>_list.html``; we "
"use ``template_name`` to tell "
":class:`~django.views.generic.list.ListView` to use our existing "
"``\"polls/index.html\"`` template."
msgstr ""
"类似地，:class:`~django.views.generic.list.ListView` 使用一个叫做  ``<app "
"name>/<model name>_list.html`` 的默认模板；我们使用 ``template_name`` 来告诉 "
":class:`~django.views.generic.list.ListView` 使用我们自己已经存在的 "
"``\"polls/index.html\"`` 模板。"

#: ../../intro/tutorial04.txt:325
msgid ""
"In previous parts of the tutorial, the templates have been provided with "
"a context that contains the ``question`` and ``latest_question_list`` "
"context variables. For ``DetailView`` the ``question`` variable is "
"provided automatically -- since we're using a Django model "
"(``Question``), Django is able to determine an appropriate name for the "
"context variable. However, for ListView, the automatically generated "
"context variable is ``question_list``. To override this we provide the "
"``context_object_name`` attribute, specifying that we want to use "
"``latest_question_list`` instead. As an alternative approach, you could "
"change your templates to match the new default context variables -- but "
"it's a lot easier to just tell Django to use the variable you want."
msgstr ""
"在之前的教程中，提供模板文件时都带有一个包含 ``question`` 和 ``latest_question_list`` 变量的 "
"context。对于 ``DetailView`` ， ``question``  变量会自动提供—— 因为我们使用 Django 的模型 "
"(Question)， Django 能够为context 变量决定一个合适的名字。然而对于ListView， 自动生成的context 变量是 "
"``question_list`` 。为了覆盖这个行为，我们提供 ``context_object_name``  属性，表示我们想使用 "
"``latest_question_list`` 。作为一种替换方案，你可以改变你的模板来匹配新的 context 变量 —— 但它告诉 "
"Django 使用你想使用的变量名更容易多了。"

#: ../../intro/tutorial04.txt:337
msgid "Run the server, and use your new polling app based on generic views."
msgstr "启动服务器，使用一下基于通用视图的新投票应用。"

#: ../../intro/tutorial04.txt:339
msgid ""
"For full details on generic views, see the :doc:`generic views "
"documentation </topics/class-based-views/index>`."
msgstr "更多关于通用视图的详细信息，请查看 :doc:`通用视图的文档 </topics/class-based-views/index>`"

#: ../../intro/tutorial04.txt:342
msgid ""
"When you're comfortable with forms and generic views, read :doc:`part 5 "
"of this tutorial</intro/tutorial05>` to learn about testing our polls "
"app."
msgstr "当你对你所写的表单和通用视图感到满意后，请阅读 :doc:`教程的第5部分 </intro/tutorial05>` 来了解如何测试我们的投票应用。"

#: ../../intro/tutorial05.txt:3
msgid "Writing your first Django app, part 5"
msgstr "编写你的第一个Django应用，第5部分"

#: ../../intro/tutorial05.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left "
"off. We've built a Web-poll application, and we'll now create some "
"automated tests for it."
msgstr ""
"这一篇从 :doc:`教程第4部分 </intro/tutorial04>` "
"结尾的地方继续讲起。我们在前几章成功的构建了一个在线投票应用，在这一部分里我们将其创建一些自动化测试。"

#: ../../intro/tutorial05.txt:10
msgid "Introducing automated testing"
msgstr "自动化测试简介"

#: ../../intro/tutorial05.txt:13
msgid "What are automated tests?"
msgstr "自动化测试是什么？"

#: ../../intro/tutorial05.txt:15
msgid "Tests are simple routines that check the operation of your code."
msgstr "测试，是用来检查代码正确性的一些简单的程序。"

#: ../../intro/tutorial05.txt:17
msgid ""
"Testing operates at different levels. Some tests might apply to a tiny "
"detail (*does a particular model method return values as expected?*) "
"while others examine the overall operation of the software (*does a "
"sequence of user inputs on the site produce the desired result?*). That's"
" no different from the kind of testing you did earlier in :doc:`Tutorial "
"2 </intro/tutorial02>`, using the :djadmin:`shell` to examine the "
"behavior of a method, or running the application and entering data to "
"check how it behaves."
msgstr ""
"测试在不同的层次中都存在。有些测试只关注某个很小的细节（某个模型的某个方法的返回值是否满足预期？），而另一些测试可能检查对莫个软件的一系列操作（某一用户输入序列是否造成了预期的结果？）。其实这和我们在"
" :doc:`教程第2部分 </intro/tutorial02>`, 里做的并没有什么不同，我们使用 shell "
"来测试某一方法的功能，或者运行某个应用并输入数据来检查它的行为。"

#: ../../intro/tutorial05.txt:25
msgid ""
"What's different in *automated* tests is that the testing work is done "
"for you by the system. You create a set of tests once, and then as you "
"make changes to your app, you can check that your code still works as you"
" originally intended, without having to perform time consuming manual "
"testing."
msgstr "真正不同的地方在于，自动化测试是由某个系统帮你自动完成的。当你创建好了一系列测试，每次修改应用代码后，就可以自动检查出修改后的代码是否还像你曾经预期的那样正常工作。你不需要话费大量时间来进行手动测试。"

#: ../../intro/tutorial05.txt:31
msgid "Why you need to create tests"
msgstr "为什么你需要写测试"

#: ../../intro/tutorial05.txt:33
msgid "So why create tests, and why now?"
msgstr "但是，为什么需要测试呢？又为什么是现在呢？"

#: ../../intro/tutorial05.txt:35
msgid ""
"You may feel that you have quite enough on your plate just learning "
"Python/Django, and having yet another thing to learn and do may seem "
"overwhelming and perhaps unnecessary. After all, our polls application is"
" working quite happily now; going through the trouble of creating "
"automated tests is not going to make it work any better. If creating the "
"polls application is the last bit of Django programming you will ever do,"
" then true, you don't need to know how to create automated tests. But, if"
" that's not the case, now is an excellent time to learn."
msgstr ""
"你可能觉得学 Python/Django "
"对你来说已经很充实了，再学一些新东西的话看起来有点负担过重并且没什么必要。毕竟，我们的投票应用看起来已经完美工作了。写一些自动测试并不能让它工作的更好。如果写一个投票应用是你想用"
" Django 完成的唯一工作，那你确实没必要学写测试。但是如果你还想写更复杂的项目，现在就是学习测试写法的最好时机了。"

#: ../../intro/tutorial05.txt:45
msgid "Tests will save you time"
msgstr "测试将节约你的时间"

#: ../../intro/tutorial05.txt:47
msgid ""
"Up to a certain point, 'checking that it seems to work' will be a "
"satisfactory test. In a more sophisticated application, you might have "
"dozens of complex interactions between components."
msgstr "在某种程度上，能够「判断出代码是否正常工作」的测试，就称得上是个令人满意的了。"

#: ../../intro/tutorial05.txt:51
msgid ""
"A change in any of those components could have unexpected consequences on"
" the application's behavior. Checking that it still 'seems to work' could"
" mean running through your code's functionality with twenty different "
"variations of your test data just to make sure you haven't broken "
"something - not a good use of your time."
msgstr "在更加复杂的应用中，各种组件之间的交互可能会及其的复杂。改变其中某一组件的行为，也有可能会造成意想不到的结果。判断「代码是否正常工作」意味着你需要用大量的数据来完整的测试全部代码的功能，以确保你的小修改没有对应用整体造成破坏——这太费时间了。"

#: ../../intro/tutorial05.txt:57
msgid ""
"That's especially true when automated tests could do this for you in "
"seconds. If something's gone wrong, tests will also assist in identifying"
" the code that's causing the unexpected behavior."
msgstr "尤其是当你发现自动化测试能在几秒钟之内帮你完成这件事时，就更会觉得手动测试实在是太浪费时间了。当某人写出错误的代码时，自动化测试还能帮助你定位错误代码的位置。"

#: ../../intro/tutorial05.txt:61
msgid ""
"Sometimes it may seem a chore to tear yourself away from your productive,"
" creative programming work to face the unglamorous and unexciting "
"business of writing tests, particularly when you know your code is "
"working properly."
msgstr "有时候你会觉得，和富有创造性和生产力的业务代码比起来，编写枯燥的测试代码实在是太无聊了，特别是当你知道你的代码完全没有问题的时候。"

#: ../../intro/tutorial05.txt:65
msgid ""
"However, the task of writing tests is a lot more fulfilling than spending"
" hours testing your application manually or trying to identify the cause "
"of a newly-introduced problem."
msgstr "然而，编写测试还是要比花费几个小时手动测试你的应用，或者为了找到某个小错误而胡乱翻看代码要有意义的多。"

#: ../../intro/tutorial05.txt:70
msgid "Tests don't just identify problems, they prevent them"
msgstr "测试不仅能发现错误，而且能预防错误"

#: ../../intro/tutorial05.txt:72
msgid ""
"It's a mistake to think of tests merely as a negative aspect of "
"development."
msgstr "「测试是开发的对立面」，这种思想是不对的。"

#: ../../intro/tutorial05.txt:74
msgid ""
"Without tests, the purpose or intended behavior of an application might "
"be rather opaque. Even when it's your own code, you will sometimes find "
"yourself poking around in it trying to find out what exactly it's doing."
msgstr "如果没有测试，整个应用的行为意图会变得更加的不清晰。甚至当你在看自己写的代码时也是这样，有时候你需要仔细研读一段代码才能搞清楚它有什么用。"

#: ../../intro/tutorial05.txt:78
msgid ""
"Tests change that; they light up your code from the inside, and when "
"something goes wrong, they focus light on the part that has gone wrong - "
"*even if you hadn't even realized it had gone wrong*."
msgstr "而测试的出现改变了这种情况。测试就好像是从内部仔细检查你的代码，当有些地方出错时，这些地方将会变得很显眼——就算你自己没有意识到那里写错了。"

#: ../../intro/tutorial05.txt:83
msgid "Tests make your code more attractive"
msgstr "测试使你的代码更有吸引力"

#: ../../intro/tutorial05.txt:85
msgid ""
"You might have created a brilliant piece of software, but you will find "
"that many other developers will simply refuse to look at it because it "
"lacks tests; without tests, they won't trust it. Jacob Kaplan-Moss, one "
"of Django's original developers, says \"Code without tests is broken by "
"design.\""
msgstr ""
"你也许遇到过这种情况：你编写了一个绝赞的软件，但是其他开发者看都不看它一眼，因为它缺少测试。没有测试的代码不值得信任。 Django "
"最初开发者之一的 Jacob Kaplan-Moss 说过：“项目规划时没有包含测试是不科学的。”"

#: ../../intro/tutorial05.txt:90
msgid ""
"That other developers want to see tests in your software before they take"
" it seriously is yet another reason for you to start writing tests."
msgstr "其他的开发者希望在正式使用你的代码前看到它通过了测试，这是你需要写测试的另一个重要原因。"

#: ../../intro/tutorial05.txt:94
msgid "Tests help teams work together"
msgstr "测试有利于团队协作"

#: ../../intro/tutorial05.txt:96
msgid ""
"The previous points are written from the point of view of a single "
"developer maintaining an application. Complex applications will be "
"maintained by teams. Tests guarantee that colleagues don't inadvertently "
"break your code (and that you don't break theirs without knowing). If you"
" want to make a living as a Django programmer, you must be good at "
"writing tests!"
msgstr ""
"前面的几点都是从单人开发的角度来说的。复杂的应用可能由团队维护。测试的存在保证了协作者不会不小心破坏了了你的代码(也保证你不会不小心弄坏他们的)。如果你想作为一个"
" Django 程序员谋生的话，你必须擅长编写测试！"

#: ../../intro/tutorial05.txt:103
msgid "Basic testing strategies"
msgstr "基础测试策略"

#: ../../intro/tutorial05.txt:105
msgid "There are many ways to approach writing tests."
msgstr "测试有几种不同的应用方法。"

#: ../../intro/tutorial05.txt:107
msgid ""
"Some programmers follow a discipline called \"`test-driven "
"development`_\"; they actually write their tests before they write their "
"code. This might seem counter-intuitive, but in fact it's similar to what"
" most people will often do anyway: they describe a problem, then create "
"some code to solve it. Test-driven development simply formalizes the "
"problem in a Python test case."
msgstr ""
"一些开发者遵循 \"`测试驱动`_\" "
"的开发原则，他们在写代码之前先写测试。这种方法看起来有点反直觉，但事实上，这和大多数人日常的做法是相吻合的。我们会先描述一个问题，然后写代码来解决它。「测试驱动」的开发方法只是将问题的描述抽象为了"
" Python 的测试样例。"

#: ../../intro/tutorial05.txt:113
msgid ""
"More often, a newcomer to testing will create some code and later decide "
"that it should have some tests. Perhaps it would have been better to "
"write some tests earlier, but it's never too late to get started."
msgstr "更普遍的情况是，一个刚接触自动化测试的新手更倾向于先写代码，然后再写测试。虽然提前写测试可能更好，但是晚点写起码也比没有强。"

#: ../../intro/tutorial05.txt:117
msgid ""
"Sometimes it's difficult to figure out where to get started with writing "
"tests. If you have written several thousand lines of Python, choosing "
"something to test might not be easy. In such a case, it's fruitful to "
"write your first test the next time you make a change, either when you "
"add a new feature or fix a bug."
msgstr ""
"有时候很难决定从测试该哪里开始下手。如果你已经写了几千行 Python "
"代码了，选择从哪里开始写测试确实不怎么简单。如果是这种情况，那么在你下次修改代码（比如加新功能，或者修复 Bug）之前写个测试是比较合理且有效的。"

#: ../../intro/tutorial05.txt:122
msgid "So let's do that right away."
msgstr "所以，我们现在就开始写吧。"

#: ../../intro/tutorial05.txt:127
msgid "Writing our first test"
msgstr "第一个测试"

#: ../../intro/tutorial05.txt:130
msgid "We identify a bug"
msgstr "首先得有个 Bug"

#: ../../intro/tutorial05.txt:132
msgid ""
"Fortunately, there's a little bug in the ``polls`` application for us to "
"fix right away: the ``Question.was_published_recently()`` method returns "
"``True`` if the ``Question`` was published within the last day (which is "
"correct) but also if the ``Question``’s ``pub_date`` field is in the "
"future (which certainly isn't)."
msgstr ""
"幸运的是，我们的 `polls`` 应用现在就有一个小 Bug 需要被修复：我们的要求是如果 Question 是在一天之内发布的， "
"``Question.was_published_recently()`` 方法将会返回 ``True`` ，然而现在这个方法在 "
"``Question`` 的 ``pub_date`` 字段比当前时间还晚时也会返回 True(这是个 Bug)。 "

#: ../../intro/tutorial05.txt:137
msgid ""
"To check if the bug really exists, using the Admin create a question "
"whose date lies in the future and check the method using the "
":djadmin:`shell`::"
msgstr ""
"你能从管理页面确认这个 Bug。创建一个发布日期是将来的投票，在投票列表里你会看到它被标明为最近发布（published "
"recently）。也可以从 :djadmin:`shell`: 里确认 Bug："

#: ../../intro/tutorial05.txt:149
msgid "Since things in the future are not 'recent', this is clearly wrong."
msgstr "因为将来发生的是肯定不是最近发生的，所以代码明显是错误的。"

#: ../../intro/tutorial05.txt:152
msgid "Create a test to expose the bug"
msgstr "创建一个测试来暴露这个错误"

#: ../../intro/tutorial05.txt:154
msgid ""
"What we've just done in the :djadmin:`shell` to test for the problem is "
"exactly what we can do in an automated test, so let's turn that into an "
"automated test."
msgstr "我们刚刚在 :djadmin:`shell` 里做的测试也就是自动化测试应该做的工作。所以我们来把它改写成自动化的吧。"

#: ../../intro/tutorial05.txt:157
msgid ""
"A conventional place for an application's tests is in the application's "
"``tests.py`` file; the testing system will automatically find tests in "
"any file whose name begins with ``test``."
msgstr ""
"按照惯例，Django 应用的测试因该卸载应用的 ``tests.py`` 文件里。测试系统会自动的在所有以 ``tests`` "
"开头的文件里寻找并执行测试代码。"

#: ../../intro/tutorial05.txt:161
msgid "Put the following in the ``tests.py`` file in the ``polls`` application:"
msgstr "将下面在  ``polls`` 应用 ``tests.py`` 文件："

#: ../../intro/tutorial05.txt:185
msgid ""
"What we have done here is created a :class:`django.test.TestCase` "
"subclass with a method that creates a ``Question`` instance with a "
"``pub_date`` in the future. We then check the output of "
"``was_published_recently()`` - which *ought* to be False."
msgstr ""
"我们创建了一个 :class:`django.test.TestCase` 的子类，并添加了一个方法。在此方法中我们创建了一个 "
"``pub_date`` 字段值在将来的 ``Question`` 实例，然后检查它的 ``was_published_recently()`` "
"方法的返回值——它应该是 False。"

#: ../../intro/tutorial05.txt:191
msgid "Running tests"
msgstr "运行测试"

#: ../../intro/tutorial05.txt:193
msgid "In the terminal, we can run our test::"
msgstr "在终端中，我们通过输入以下代码运行测试："

#: ../../intro/tutorial05.txt:197
msgid "and you'll see something like::"
msgstr "你将会看到运行结果："

#: ../../intro/tutorial05.txt:215
msgid "What happened is this:"
msgstr "发生了什么呢？以下是自动化测试的运行过程："

#: ../../intro/tutorial05.txt:217
msgid ""
"``python manage.py test polls`` looked for tests in the ``polls`` "
"application"
msgstr "``python manage.py test polls``  将会寻找  ``polls`` 应用里的测试代码"

#: ../../intro/tutorial05.txt:219
msgid "it found a subclass of the :class:`django.test.TestCase` class"
msgstr "它找到了一个 :class:`django.test.TestCase` 的子类"

#: ../../intro/tutorial05.txt:221
msgid "it created a special database for the purpose of testing"
msgstr "它创建一个特殊的数据库供测试使用"

#: ../../intro/tutorial05.txt:223
msgid "it looked for test methods - ones whose names begin with ``test``"
msgstr "它在类中寻找测试方法——以 ``test`` 开头的方法。"

#: ../../intro/tutorial05.txt:225
msgid ""
"in ``test_was_published_recently_with_future_question`` it created a "
"``Question`` instance whose ``pub_date`` field is 30 days in the future"
msgstr ""
"在  ``test_was_published_recently_with_future_question`` 方法中，它创建了一个 "
"``pub_date`` 值为未来第 30 天的 ``Question`` 实例。"

#: ../../intro/tutorial05.txt:228
msgid ""
"... and using the ``assertEqual()`` method, it discovered that its "
"``was_published_recently()`` returns ``True``, though we wanted it to "
"return ``False``"
msgstr ""
"然后使用 ``assertEqual()`` 方法，发现 ``was_published_recently()`` 返回了 "
"``True``，而我们希望它返回  ``False``"

#: ../../intro/tutorial05.txt:232
msgid ""
"The test informs us which test failed and even the line on which the "
"failure occurred."
msgstr "测试系统通知我们哪些测试样例失败了，和造成测试失败的代码所在的行号。"

#: ../../intro/tutorial05.txt:236
msgid "Fixing the bug"
msgstr "修复 Bug"

#: ../../intro/tutorial05.txt:238
msgid ""
"We already know what the problem is: "
"``Question.was_published_recently()`` should return ``False`` if its "
"``pub_date`` is in the future. Amend the method in ``models.py``, so that"
" it will only return ``True`` if the date is also in the past:"
msgstr ""
"我们现在知道了，问题出在当 ``pub_date`` 为将来时， ``Question.was_published_recently()`` "
"应该返回 ``False``。我们去修改 models.py 里的方法，让它只在日期是过去的时候才返回 ``True``："

#: ../../intro/tutorial05.txt:250
msgid "and run the test again::"
msgstr "然后我们重新运行测试："

#: ../../intro/tutorial05.txt:260
msgid ""
"After identifying a bug, we wrote a test that exposes it and corrected "
"the bug in the code so our test passes."
msgstr "在出现 Bug 之后，我们编写了能够发现这个 Bug 的自动化测试。在修复 Bug 之后，我们的代码顺利的通过了测试。"

#: ../../intro/tutorial05.txt:263
msgid ""
"Many other things might go wrong with our application in the future, but "
"we can be sure that we won't inadvertently reintroduce this bug, because "
"simply running the test will warn us immediately. We can consider this "
"little portion of the application pinned down safely forever."
msgstr ""
"将来，我们的应用可能会出现其他的问题，但是我们可以肯定的是，一定不会再次出现这个 "
"Bug，因为只要简单的运行一遍测试，就会立刻收到警告。我们可以认为应用的这一小部分代码永远是安全的。"

#: ../../intro/tutorial05.txt:269
msgid "More comprehensive tests"
msgstr "更全面的测试"

#: ../../intro/tutorial05.txt:271
msgid ""
"While we're here, we can further pin down the "
"``was_published_recently()`` method; in fact, it would be positively "
"embarrassing if in fixing one bug we had introduced another."
msgstr ""
"我们已经搞定一小部分了，现在可以考虑全面的测试 ``was_published_recently()`` "
"这个方法以确定它的安全性，然后就可以把这个方法稳定下来了。事实上，在修复一个 Bug 时不小心引入另一个 Bug 会是非常令人尴尬的。"

#: ../../intro/tutorial05.txt:275
msgid ""
"Add two more test methods to the same class, to test the behavior of the "
"method more comprehensively:"
msgstr "我们在上次写的类里再增加两个测试，来更全面的测试这个方法："

#: ../../intro/tutorial05.txt:299
msgid ""
"And now we have three tests that confirm that "
"``Question.was_published_recently()`` returns sensible values for past, "
"recent, and future questions."
msgstr ""
"现在，我们有三个测试来确保 ``Question.was_published_recently()`` "
"方法对于过去，最近，和将来的三种情况都返回正确的值。"

#: ../../intro/tutorial05.txt:302
msgid ""
"Again, ``polls`` is a simple application, but however complex it grows in"
" the future and whatever other code it interacts with, we now have some "
"guarantee that the method we have written tests for will behave in "
"expected ways."
msgstr ""
"再次申明，尽管  ``polls``  "
"现在是个非常简单的应用，但是无论它以后成长到多么复杂，要和其他代码进行怎样的交互，我们都能保证进行过测试的那些方法的行为永远是符合预期的。"

#: ../../intro/tutorial05.txt:307
msgid "Test a view"
msgstr "测试视图"

#: ../../intro/tutorial05.txt:309
msgid ""
"The polls application is fairly undiscriminating: it will publish any "
"question, including ones whose ``pub_date`` field lies in the future. We "
"should improve this. Setting a ``pub_date`` in the future should mean "
"that the Question is published at that moment, but invisible until then."
msgstr ""
"我们的投票应用对所有问题都一视同仁：它将会发布所有的问题，也包括那些 ``pub_date`` 字段值是未来的问题。我们应该改善这一点。将 "
"``pub_date`` 设置为将来应该被解释为这个问题将在所填写的时间点才被发布，而在之前是不可见的。"

#: ../../intro/tutorial05.txt:315
msgid "A test for a view"
msgstr "针对视图的测试"

#: ../../intro/tutorial05.txt:317
msgid ""
"When we fixed the bug above, we wrote the test first and then the code to"
" fix it. In fact that was a simple example of test-driven development, "
"but it doesn't really matter in which order we do the work."
msgstr "为了修复上述 Bug ，我们这次先编写测试，然后再去改代码。事实上，这是一个「测试驱动」开发模式的实例，但其实这两者的顺序不太重要。"

#: ../../intro/tutorial05.txt:321
msgid ""
"In our first test, we focused closely on the internal behavior of the "
"code. For this test, we want to check its behavior as it would be "
"experienced by a user through a web browser."
msgstr "在我们的第一个测试中，我们关注代码的内部行为。我们通过假装有用户使用浏览器访问被测试的应用来检查代码行为是否符合预期。"

#: ../../intro/tutorial05.txt:325
msgid ""
"Before we try to fix anything, let's have a look at the tools at our "
"disposal."
msgstr "在我们动手之前，先看看需要用到的工具们。"

#: ../../intro/tutorial05.txt:328
msgid "The Django test client"
msgstr "Django 测试工具之 Client"

#: ../../intro/tutorial05.txt:330
msgid ""
"Django provides a test :class:`~django.test.Client` to simulate a user "
"interacting with the code at the view level.  We can use it in "
"``tests.py`` or even in the :djadmin:`shell`."
msgstr ""
"Django 提供了一个供测试使用的 :class:`~django.test.Client` 来模拟用户和视图层代码的交互。我们能在 "
"``tests.py`` 甚至是  :djadmin:`shell` 中使用它。"

#: ../../intro/tutorial05.txt:334
msgid ""
"We will start again with the :djadmin:`shell`, where we need to do a "
"couple of things that won't be necessary in ``tests.py``. The first is to"
" set up the test environment in the :djadmin:`shell`::"
msgstr ""
"我们依照惯例从  :djadmin:`shell` 开始，首先我们要做一些在 ``tests.py`` 里并不需要的准备工作。第一步是在  "
":djadmin:`shell` 中配置测试环境："

#: ../../intro/tutorial05.txt:341
msgid ""
":meth:`~django.test.utils.setup_test_environment` installs a template "
"renderer which will allow us to examine some additional attributes on "
"responses such as ``response.context`` that otherwise wouldn't be "
"available. Note that this method *does not* setup a test database, so the"
" following will be run against the existing database and the output may "
"differ slightly depending on what questions you already created."
msgstr ""
":meth:`~django.test.utils.setup_test_environment`  安装了一个特殊的模板渲染器，它能让我们使用 "
"response 的一些在正常情况下不可用的附加属性，比如 ``response.context`` "
"。*注意*，这个方法并不会配置测试数据库，所以接下来的代码将会当前存在的数据库上运行，输出的内容可能由于数据库内容的不同而不同。"

#: ../../intro/tutorial05.txt:348
msgid ""
"Next we need to import the test client class (later in ``tests.py`` we "
"will use the :class:`django.test.TestCase` class, which comes with its "
"own client, so this won't be required)::"
msgstr ""
"然后我们需要导入 :class:`django.test.TestCase` 类(在后续 ``tests.py`` 的实例中我们将会使用 "
":class:`django.test.TestCase` 类，这个类里包含了自己的 client 实例，所以不需要这一步)"

#: ../../intro/tutorial05.txt:356
msgid "With that ready, we can ask the client to do some work for us::"
msgstr "搞定了之后，我们可以要求 client 来为我们工作了："

#: ../../intro/tutorial05.txt:389
msgid "Improving our view"
msgstr "改善视图代码"

#: ../../intro/tutorial05.txt:391
msgid ""
"The list of polls shows polls that aren't published yet (i.e. those that "
"have a ``pub_date`` in the future). Let's fix that."
msgstr "现在的投票列表会显示将来的投票( ``pub_date`` 值是将来的那些)。我们来修复这个问题。"

#: ../../intro/tutorial05.txt:394
msgid ""
"In :doc:`Tutorial 4 </intro/tutorial04>` we introduced a class-based "
"view, based on :class:`~django.views.generic.list.ListView`:"
msgstr ""
"在 :doc:`教程的第四部分 </intro/tutorial04>`  里，我们介绍了基于 "
":class:`~django.views.generic.list.ListView` 的视图类："

#: ../../intro/tutorial05.txt:408
msgid ""
"We need to amend the ``get_queryset()`` method and change it so that it "
"also checks the date by comparing it with ``timezone.now()``. First we "
"need to add an import:"
msgstr ""
"我们需要改进  ``get_queryset()`` 方法，让他它能通过将 Question 的 pub_data 属性与 "
"``timezone.now()`` 相比较来判断是否应该显示此 Question。首先我们需要一行 import 语句："

#: ../../intro/tutorial05.txt:417
msgid "and then we must amend the ``get_queryset`` method like so:"
msgstr "然后我们把  ``get_queryset``  方法改写成下面这样："

#: ../../intro/tutorial05.txt:431
msgid ""
"``Question.objects.filter(pub_date__lte=timezone.now())`` returns a "
"queryset containing ``Question``\\s whose ``pub_date`` is less than or "
"equal to - that is, earlier than or equal to - ``timezone.now``."
msgstr ""
" ``Question.objects.filter(pub_date__lte=timezone.now())`` 返回一个由 pub_date"
" 小于或等于(也就是早于或等于)``timezone.now``  的 ``Question`` 组成的集合。 "

#: ../../intro/tutorial05.txt:436
msgid "Testing our new view"
msgstr "测试新视图"

#: ../../intro/tutorial05.txt:438
msgid ""
"Now you can satisfy yourself that this behaves as expected by firing up "
"the runserver, loading the site in your browser, creating ``Questions`` "
"with dates in the past and future, and checking that only those that have"
" been published are listed.  You don't want to have to do that *every "
"single time you make any change that might affect this* - so let's also "
"create a test, based on our :djadmin:`shell` session above."
msgstr ""
"启动服务器、在浏览器中载入站点、创建一些发布时间在过去和将来的  ``Questions`` ，然后检验只有已经发布的  "
"``Questions``  会展示出来，现在你可以对自己感到满意了。*你不想每次修改可能与这相关的代码时都重复这样做* —— 所以让我们基于以上"
" :djadmin:`shell`  会话中的内容，再编写一个测试。"

#: ../../intro/tutorial05.txt:445
msgid "Add the following to ``polls/tests.py``:"
msgstr "将下面的代码添加到 ``polls/tests.py`` ："

#: ../../intro/tutorial05.txt:452
msgid ""
"and we'll create a shortcut function to create questions as well as a new"
" test class:"
msgstr "然后我们写一个公用的快捷函数用于创建投票问题，再为视图创建一个测试类："

#: ../../intro/tutorial05.txt:528
msgid "Let's look at some of these more closely."
msgstr "让我们更详细地看下以上这些内容。"

#: ../../intro/tutorial05.txt:530
msgid ""
"First is a question shortcut function, ``create_question``, to take some "
"repetition out of the process of creating questions."
msgstr "首先是一个快捷函数 ``create_question``，它封装了创建投票的流程，减少了重复代码。"

#: ../../intro/tutorial05.txt:533
msgid ""
"``test_index_view_with_no_questions`` doesn't create any questions, but "
"checks the message: \"No polls are available.\" and verifies the "
"``latest_question_list`` is empty. Note that the "
":class:`django.test.TestCase` class provides some additional assertion "
"methods. In these examples, we use "
":meth:`~django.test.SimpleTestCase.assertContains()` and "
":meth:`~django.test.TransactionTestCase.assertQuerysetEqual()`."
msgstr ""
"``test_index_view_with_no_questions`` 方法里没有创建任何投票，它检查返回的网页上有没有 \"No polls"
" are available.\" 这段消息和 ``latest_question_list`` 是否为空。注意到 "
":class:`django.test.TestCase` 类提供了一些额外的 assert 方法，在这个例子中，我们使用了 "
":meth:`~django.test.SimpleTestCase.assertContains()` 和 "
":meth:`~django.test.TransactionTestCase.assertQuerysetEqual()` 。"

#: ../../intro/tutorial05.txt:540
msgid ""
"In ``test_index_view_with_a_past_question``, we create a question and "
"verify that it appears in the list."
msgstr "在 ``test_index_view_with_a_past_question`` 方法中，我们创建了一个投票并检查它是否出现在列表中。"

#: ../../intro/tutorial05.txt:543
msgid ""
"In ``test_index_view_with_a_future_question``, we create a question with "
"a ``pub_date`` in the future. The database is reset for each test method,"
" so the first question is no longer there, and so again the index "
"shouldn't have any questions in it."
msgstr ""
"在 ``test_index_view_with_a_future_question`` 方法中，我们创建了一个 ``pub_date``  "
"在将来的投票。数据库会在每次调用测试方法之前被重置，所以第一个方法里创建的投票已经没了，所以此时我们希望看到的是一个没有任何投票的目录页。"

#: ../../intro/tutorial05.txt:548
msgid ""
"And so on. In effect, we are using the tests to tell a story of admin "
"input and user experience on the site, and checking that at every state "
"and for every new change in the state of the system, the expected results"
" are published."
msgstr "剩下的那些也都差不多。实际上，测试就是假装一些管理员的输入，然后通过用户端的表现是否符合预期来判断新加入的改变是否破坏了原有的系统状态。"

#: ../../intro/tutorial05.txt:553
msgid "Testing the ``DetailView``"
msgstr "测试 ``DetailView``"

#: ../../intro/tutorial05.txt:555
msgid ""
"What we have works well; however, even though future questions don't "
"appear in the *index*, users can still reach them if they know or guess "
"the right URL. So we need to add a similar  constraint to ``DetailView``:"
msgstr ""
"我们的工作似乎已经很完美了？不，还有一个问题：就算在将来发布的那些投票不会在目录页 *index* 里出现，但是用户还是能够通过猜测 URL "
"的方式访问到他们。所以我们得在 ``DetailView`` 里增加一些约束："

#: ../../intro/tutorial05.txt:570
msgid ""
"And of course, we will add some tests, to check that a ``Question`` whose"
" ``pub_date`` is in the past can be displayed, and that one with a "
"``pub_date`` in the future is not:"
msgstr ""
"当然，我们将增加一些测试来检验 ``pub_date``  在过去的 ``Question`` 可以显示出来，而  ``pub_date`` "
"在未来的不可以："

#: ../../intro/tutorial05.txt:603
msgid "Ideas for more tests"
msgstr "更多的测试思路"

#: ../../intro/tutorial05.txt:605
msgid ""
"We ought to add a similar ``get_queryset`` method to ``ResultsView`` and "
"create a new test class for that view. It'll be very similar to what we "
"have just created; in fact there will be a lot of repetition."
msgstr ""
"我们应该给 ``ResultsView`` 也增加一个类似的 ``get_queryset`` "
"方法，并且为它创建测试。这和我们之前干的差不多，事实上，基本就是重复一遍。"

#: ../../intro/tutorial05.txt:609
msgid ""
"We could also improve our application in other ways, adding tests along "
"the way. For example, it's silly that ``Questions`` can be published on "
"the site that have no ``Choices``. So, our views could check for this, "
"and exclude such ``Questions``. Our tests would create a ``Question`` "
"without ``Choices`` and then test that it's not published, as well as "
"create a similar ``Question`` *with* ``Choices``, and test that it *is* "
"published."
msgstr ""
"我们还可以从各个方面改进投票应用，但是测试会一直伴随我们。比方说，在目录页上显示一个没有选项  ``Choices`` "
"的投票问题就没什么意义。我们可以检查并排除这样的投票题。测试里则可以创建一个没有选项的投票，然后检查它是否被显示在目录上。当然也要创建一个有选项的投票，然后确认它确实被显示了。"

#: ../../intro/tutorial05.txt:616
msgid ""
"Perhaps logged-in admin users should be allowed to see unpublished "
"``Questions``, but not ordinary visitors. Again: whatever needs to be "
"added to the software to accomplish this should be accompanied by a test,"
" whether you write the test first and then make the code pass the test, "
"or work out the logic in your code first and then write a test to prove "
"it."
msgstr "恩，也许你想让登录的管理员能在目录上够看见未被发布的那些投票，但是其他的用户看不到。不管怎么说，如果你想要增加一个新功能，那么同时一定要为它编写测试。不过你是先写代码还是先写测试那就随你了。"

#: ../../intro/tutorial05.txt:622
msgid ""
"At a certain point you are bound to look at your tests and wonder whether"
" your code is suffering from test bloat, which brings us to:"
msgstr "在未来的某个时刻，你一定会去查看测试代码，然后开始怀疑：「这么多的测试不会使代码越来越复杂吗？」。别着急，我们马上就会谈到这一点。"

#: ../../intro/tutorial05.txt:626
msgid "When testing, more is better"
msgstr "测试那是越多越好"

#: ../../intro/tutorial05.txt:628
msgid ""
"It might seem that our tests are growing out of control. At this rate "
"there will soon be more code in our tests than in our application, and "
"the repetition is unaesthetic, compared to the elegant conciseness of the"
" rest of our code."
msgstr "貌似我们的测试多的快要失去控制了。按照这样发展下去，测试代码就要变得比应用的实际代码还要多了。而且测试代码大多都是重复且不优雅的，特别是在和业务代码比起来的时候，这种感觉更加明显。"

#: ../../intro/tutorial05.txt:632
msgid ""
"**It doesn't matter**. Let them grow. For the most part, you can write a "
"test once and then forget about it. It will continue performing its "
"useful function as you continue to develop your program."
msgstr "**但是这没关系！**。就让测试代码继续肆意增长吧。大部分情况下，你写完一个测试之后就可以忘掉它了。在你继续开发的过程中，它会一直默默无闻地为你做贡献的。"

#: ../../intro/tutorial05.txt:636
msgid ""
"Sometimes tests will need to be updated. Suppose that we amend our views "
"so that only ``Questions`` with ``Choices`` are published. In that case, "
"many of our existing tests will fail - *telling us exactly which tests "
"need to be amended to bring them up to date*, so to that extent tests "
"help look after themselves."
msgstr ""
"但有时测试也需要更新。想象一下如果我们真的想让目录只显示有选项的那些投票，那么只前写的很多测试就都会失败。但是 "
"这也明确地告诉了我们哪些测试需要被更新，所以增加的测试会自行测试向前的兼容性。"

#: ../../intro/tutorial05.txt:641
msgid ""
"At worst, as you continue developing, you might find that you have some "
"tests that are now redundant. Even that's not a problem; in testing "
"redundancy is a *good* thing."
msgstr "最坏的情况是，当你继续开发的时候，发现之前的一些测试现在看来是多余的。但是这也不是什么问题，冗余的测试也是件好事。"

#: ../../intro/tutorial05.txt:645
msgid ""
"As long as your tests are sensibly arranged, they won't become "
"unmanageable. Good rules-of-thumb include having:"
msgstr "如果你对测试有个整体规划，那么它们就几乎不会变得混乱。下面有几条好的建议："

#: ../../intro/tutorial05.txt:648
msgid "a separate ``TestClass`` for each model or view"
msgstr "对于每个模型和视图都建立单独的测试类"

#: ../../intro/tutorial05.txt:649
msgid "a separate test method for each set of conditions you want to test"
msgstr "每个测试方法之测试一个功能"

#: ../../intro/tutorial05.txt:650
msgid "test method names that describe their function"
msgstr "给每个测试方法起个能描述其功能的名字"

#: ../../intro/tutorial05.txt:653
msgid "Further testing"
msgstr "深入代码测试"

#: ../../intro/tutorial05.txt:655
msgid ""
"This tutorial only introduces some of the basics of testing. There's a "
"great deal more you can do, and a number of very useful tools at your "
"disposal to achieve some very clever things."
msgstr "在本教程中，我们仅仅是了解了测试的基础知识。你能做的还有很多，而且世界上有很多有用的工具来帮你完成这些有意义的事。"

#: ../../intro/tutorial05.txt:659
msgid ""
"For example, while our tests here have covered some of the internal logic"
" of a model and the way our views publish information, you can use an "
"\"in-browser\" framework such as Selenium_ to test the way your HTML "
"actually renders in a browser. These tools allow you to check not just "
"the behavior of your Django code, but also, for example, of your "
"JavaScript. It's quite something to see the tests launch a browser, and "
"start interacting with your site, as if a human being were driving it! "
"Django includes :class:`~django.test.LiveServerTestCase` to facilitate "
"integration with tools like Selenium."
msgstr ""
"举个例子，在我们上述的测试中，已经从代码逻辑和视图响应的角度检查了应用的输出，现在你可以从一个更加用户的角度来检查最终渲染出的 HTML "
"是否符合预期，使用 Selenium 可以很轻松的完成这件事。这个工具不仅可以测试 Django 框架里的代码，还可以检查其他部分，比如说你的 "
"JavaScript。它假装成是一个正在和你站点进行交互的浏览器，就好像有个真人在访问网站一样！Django 它提供了  "
":class:`~django.test.LiveServerTestCase`  来和 Selenium 这样的工具进行交互。"

#: ../../intro/tutorial05.txt:668
msgid ""
"If you have a complex application, you may want to run tests "
"automatically with every commit for the purposes of `continuous "
"integration`_, so that quality control is itself - at least partially - "
"automated."
msgstr ""
"如果你在开发一个很复杂的应用的话，你也许想在每次提交代码时自动运行测试，也就是我们所说的持续整合  `continuous "
"integration`_ ，这样的话就实现质量控制的自动化，起码是部分自动化。"

#: ../../intro/tutorial05.txt:672
msgid ""
"A good way to spot untested parts of your application is to check code "
"coverage. This also helps identify fragile or even dead code. If you "
"can't test a piece of code, it usually means that code should be "
"refactored or removed. Coverage will help to identify dead code. See :ref"
":`topics-testing-code-coverage` for details."
msgstr ""
"一个找出代码中未被测试部分的方法是检查代码覆盖率。它有助于找出代码中的薄弱部分和无用部分。如果你无法测试一段代码，通常说明这段代码需要被重构或者删除。想知道代码覆盖率和无用代码的详细信息，请看文档"
" 和 :ref:`topics-testing-code-coverage` 结合使用。"

#: ../../intro/tutorial05.txt:678
msgid ""
":doc:`Testing in Django </topics/testing/index>` has comprehensive "
"information about testing."
msgstr "文档 :doc:`Testing in Django </topics/testing/index>` 里有关于测试的更多信息。"

#: ../../intro/tutorial05.txt:687
msgid ""
"For full details on testing, see :doc:`Testing in Django "
"</topics/testing/index>`."
msgstr "如果你想深入了解测试，就去看 :doc:`Testing in Django </topics/testing/index>` 。"

#: ../../intro/tutorial05.txt:690
msgid ""
"When you're comfortable with testing Django views, read :doc:`part 6 of "
"this tutorial</intro/tutorial06>` to learn about static files management."
msgstr ""
"当你已经比较熟悉该如何测试 Django 的视图之后，就可以继续于读 :doc:`教程第6部分</intro/tutorial06>`   "
"，来学习关于静态文件管理的相关知识。"

#: ../../intro/tutorial06.txt:3
msgid "Writing your first Django app, part 6"
msgstr "编写你的第一个Django应用，第6部分"

#: ../../intro/tutorial06.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 5 </intro/tutorial05>` left "
"off. We've built a tested Web-poll application, and we'll now add a "
"stylesheet and an image."
msgstr ""
"这一篇从  :doc:`教程第5部分 </intro/tutorial05>`  "
"结尾的地方继续讲起。再上一节中我们为网络投票程序编写了测试，而现在我们要为它加上样式和图片。"

#: ../../intro/tutorial06.txt:9
msgid ""
"Aside from the HTML generated by the server, web applications generally "
"need to serve additional files — such as images, JavaScript, or CSS — "
"necessary to render the complete web page. In Django, we refer to these "
"files as \"static files\"."
msgstr ""
"除了服务端生成的 HTML 以外，网络应用通常需要一些其他的文件——比如图片，脚本和样式表——来帮助渲染网络页面。在 Django "
"中，我们把这些文件统称为“静态文件”。"

#: ../../intro/tutorial06.txt:14
msgid ""
"For small projects, this isn't a big deal, because you can just keep the "
"static files somewhere your web server can find it. However, in bigger "
"projects -- especially those comprised of multiple apps -- dealing with "
"the multiple sets of static files provided by each application starts to "
"get tricky."
msgstr "对于小项目来说，这个问题没什么大不了的，因为你可以把这些静态文件随便放在哪，只要服务程序能够找到它们就行。然而在大项目——特别是由好几个应用组成的大项目——中，处理不同应用所需要的静态文件的工作就显得有点麻烦了。"

#: ../../intro/tutorial06.txt:20
msgid ""
"That's what ``django.contrib.staticfiles`` is for: it collects static "
"files from each of your applications (and any other places you specify) "
"into a single location that can easily be served in production."
msgstr ""
"这就是 ``django.contrib.staticfiles`` "
"存在的意义：它将各个应用的静态文件(和一些你指明的目录里的文件)统一收集起来，这样一来，在生产环境中，这些文件就会集中在一个便于分发的地方。"

#: ../../intro/tutorial06.txt:25
msgid "Customize your *app's* look and feel"
msgstr "自定义*应用*的界面和风格"

#: ../../intro/tutorial06.txt:27
msgid ""
"First, create a directory called ``static`` in your ``polls`` directory. "
"Django will look for static files there, similarly to how Django finds "
"templates inside ``polls/templates/``."
msgstr ""

#: ../../intro/tutorial06.txt:31
msgid ""
"Django's :setting:`STATICFILES_FINDERS` setting contains a list of "
"finders that know how to discover static files from various sources. One "
"of the defaults is ``AppDirectoriesFinder`` which looks for a \"static\" "
"subdirectory in each of the :setting:`INSTALLED_APPS`, like the one in "
"``polls`` we just created. The admin site uses the same directory "
"structure for its static files."
msgstr ""

#: ../../intro/tutorial06.txt:38
msgid ""
"Within the ``static`` directory you have just created, create another "
"directory called ``polls`` and within that create a file called "
"``style.css``. In other words, your stylesheet should be at "
"``polls/static/polls/style.css``. Because of how the "
"``AppDirectoriesFinder`` staticfile finder works, you can refer to this "
"static file in Django simply as ``polls/style.css``, similar to how you "
"reference the path for templates."
msgstr ""

#: ../../intro/tutorial06.txt:45
msgid "Static file namespacing"
msgstr ""

#: ../../intro/tutorial06.txt:47
msgid ""
"Just like templates, we *might* be able to get away with putting our "
"static files directly in ``polls/static`` (rather than creating another "
"``polls`` subdirectory), but it would actually be a bad idea. Django will"
" choose the first static file it finds whose name matches, and if you had"
" a static file with the same name in a *different* application, Django "
"would be unable to distinguish between them. We need to be able to point "
"Django at the right one, and the easiest way to ensure this is by "
"*namespacing* them. That is, by putting those static files inside "
"*another* directory named for the application itself."
msgstr ""

#: ../../intro/tutorial06.txt:57
msgid ""
"Put the following code in that stylesheet "
"(``polls/static/polls/style.css``):"
msgstr ""

#: ../../intro/tutorial06.txt:66
msgid ""
"Next, add the following at the top of "
"``polls/templates/polls/index.html``:"
msgstr ""

#: ../../intro/tutorial06.txt:75
#, python-format
msgid ""
"The ``{% static %}`` template tag generates the absolute URL of static "
"files."
msgstr ""

#: ../../intro/tutorial06.txt:77
msgid ""
"That's all you need to do for development. Reload "
"``http://localhost:8000/polls/`` and you should see that the question "
"links are green (Django style!) which means that your stylesheet was "
"properly loaded."
msgstr ""

#: ../../intro/tutorial06.txt:82
msgid "Adding a background-image"
msgstr ""

#: ../../intro/tutorial06.txt:84
msgid ""
"Next, we'll create a subdirectory for images. Create an ``images`` "
"subdirectory in the ``polls/static/polls/`` directory. Inside this "
"directory, put an image called ``background.gif``. In other words, put "
"your image in ``polls/static/polls/images/background.gif``."
msgstr ""

#: ../../intro/tutorial06.txt:89
msgid "Then, add to your stylesheet (``polls/static/polls/style.css``):"
msgstr ""

#: ../../intro/tutorial06.txt:98
msgid ""
"Reload ``http://localhost:8000/polls/`` and you should see the background"
" loaded in the bottom right of the screen."
msgstr ""

#: ../../intro/tutorial06.txt:103
#, python-format
msgid ""
"Of course the ``{% static %}`` template tag is not available for use in "
"static files like your stylesheet which aren't generated by Django. You "
"should always use **relative paths** to link your static files between "
"each other, because then you can change :setting:`STATIC_URL` (used by "
"the :ttag:`static` template tag to generate its URLs) without having to "
"modify a bunch of paths in your static files as well."
msgstr ""

#: ../../intro/tutorial06.txt:110
msgid ""
"These are the **basics**. For more details on settings and other bits "
"included with the framework see :doc:`the static files howto </howto"
"/static-files/index>` and :doc:`the staticfiles reference "
"</ref/contrib/staticfiles>`. :doc:`Deploying static files </howto/static-"
"files/deployment>` discusses how to use static files on a real server."
msgstr ""

#: ../../intro/tutorial06.txt:117
msgid ""
"When you're comfortable with the static files, read :doc:`part 7 of this "
"tutorial </intro/tutorial07>` to learn how to customize Django's "
"automatically-generated admin site."
msgstr ""

#: ../../intro/tutorial07.txt:3
msgid "Writing your first Django app, part 7"
msgstr "编写你的第一个Django应用，第7部分"

#: ../../intro/tutorial07.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 6 </intro/tutorial06>` left "
"off. We're continuing the Web-poll application and will focus on "
"customizing the Django's automatically-generated admin site that we first"
" explored in :doc:`Tutorial 2 </intro/tutorial02>`."
msgstr ""

#: ../../intro/tutorial07.txt:11
msgid "Customize the admin form"
msgstr ""

#: ../../intro/tutorial07.txt:13
msgid ""
"By registering the ``Question`` model with "
"``admin.site.register(Question)``, Django was able to construct a default"
" form representation. Often, you'll want to customize how the admin form "
"looks and works. You'll do this by telling Django the options you want "
"when you register the object."
msgstr ""

#: ../../intro/tutorial07.txt:18
msgid ""
"Let's see how this works by reordering the fields on the edit form. "
"Replace the ``admin.site.register(Question)`` line with:"
msgstr ""

#: ../../intro/tutorial07.txt:34
msgid ""
"You'll follow this pattern -- create a model admin class, then pass it as"
" the second argument to ``admin.site.register()`` -- any time you need to"
" change the admin options for a model."
msgstr ""

#: ../../intro/tutorial07.txt:38
msgid ""
"This particular change above makes the \"Publication date\" come before "
"the \"Question\" field:"
msgstr ""

#: ../../intro/tutorial07.txt:44
msgid ""
"This isn't impressive with only two fields, but for admin forms with "
"dozens of fields, choosing an intuitive order is an important usability "
"detail."
msgstr ""

#: ../../intro/tutorial07.txt:47
msgid ""
"And speaking of forms with dozens of fields, you might want to split the "
"form up into fieldsets:"
msgstr ""

#: ../../intro/tutorial07.txt:66
msgid ""
"The first element of each tuple in "
":attr:`~django.contrib.admin.ModelAdmin.fieldsets` is the title of the "
"fieldset. Here's what our form looks like now:"
msgstr ""

#: ../../intro/tutorial07.txt:74
msgid "Adding related objects"
msgstr ""

#: ../../intro/tutorial07.txt:76
msgid ""
"OK, we have our Question admin page, but a ``Question`` has multiple "
"``Choice``\\s, and the admin page doesn't display choices."
msgstr ""

#: ../../intro/tutorial07.txt:79
msgid "Yet."
msgstr ""

#: ../../intro/tutorial07.txt:81
msgid ""
"There are two ways to solve this problem. The first is to register "
"``Choice`` with the admin just as we did with ``Question``. That's easy:"
msgstr ""

#: ../../intro/tutorial07.txt:93
msgid ""
"Now \"Choices\" is an available option in the Django admin. The \"Add "
"choice\" form looks like this:"
msgstr ""

#: ../../intro/tutorial07.txt:99
msgid ""
"In that form, the \"Question\" field is a select box containing every "
"question in the database. Django knows that a "
":class:`~django.db.models.ForeignKey` should be represented in the admin "
"as a ``<select>`` box. In our case, only one question exists at this "
"point."
msgstr ""

#: ../../intro/tutorial07.txt:104
msgid ""
"Also note the \"Add Another\" link next to \"Question.\" Every object "
"with a ``ForeignKey`` relationship to another gets this for free. When "
"you click \"Add Another\", you'll get a popup window with the \"Add "
"question\" form. If you add a question in that window and click \"Save\","
" Django will save the question to the database and dynamically add it as "
"the selected choice on the \"Add choice\" form you're looking at."
msgstr ""

#: ../../intro/tutorial07.txt:111
msgid ""
"But, really, this is an inefficient way of adding ``Choice`` objects to "
"the system. It'd be better if you could add a bunch of Choices directly "
"when you create the ``Question`` object. Let's make that happen."
msgstr ""

#: ../../intro/tutorial07.txt:115
msgid ""
"Remove the ``register()`` call for the ``Choice`` model. Then, edit the "
"``Question`` registration code to read:"
msgstr ""

#: ../../intro/tutorial07.txt:140
msgid ""
"This tells Django: \"``Choice`` objects are edited on the ``Question`` "
"admin page. By default, provide enough fields for 3 choices.\""
msgstr ""

#: ../../intro/tutorial07.txt:143
msgid "Load the \"Add question\" page to see how that looks:"
msgstr ""

#: ../../intro/tutorial07.txt:148
msgid ""
"It works like this: There are three slots for related Choices -- as "
"specified by ``extra`` -- and each time you come back to the \"Change\" "
"page for an already-created object, you get another three extra slots."
msgstr ""

#: ../../intro/tutorial07.txt:152
msgid ""
"At the end of the three current slots you will find an \"Add another "
"Choice\" link.  If you click on it, a new slot will be added. If you want"
" to remove the added slot, you can click on the X to the top right of the"
" added slot. Note that you can't remove the original three slots. This "
"image shows an added slot:"
msgstr ""

#: ../../intro/tutorial07.txt:160
msgid ""
"One small problem, though. It takes a lot of screen space to display all "
"the fields for entering related ``Choice`` objects. For that reason, "
"Django offers a tabular way of displaying inline related objects; you "
"just need to change the ``ChoiceInline`` declaration to read:"
msgstr ""

#: ../../intro/tutorial07.txt:171
msgid ""
"With that ``TabularInline`` (instead of ``StackedInline``), the related "
"objects are displayed in a more compact, table-based format:"
msgstr ""

#: ../../intro/tutorial07.txt:177
msgid ""
"Note that there is an extra \"Delete?\" column that allows removing rows "
"added using the \"Add Another Choice\" button and rows that have already "
"been saved."
msgstr ""

#: ../../intro/tutorial07.txt:181
msgid "Customize the admin change list"
msgstr ""

#: ../../intro/tutorial07.txt:183
msgid ""
"Now that the Question admin page is looking good, let's make some tweaks "
"to the \"change list\" page -- the one that displays all the questions in"
" the system."
msgstr ""

#: ../../intro/tutorial07.txt:186
msgid "Here's what it looks like at this point:"
msgstr ""

#: ../../intro/tutorial07.txt:191
msgid ""
"By default, Django displays the ``str()`` of each object. But sometimes "
"it'd be more helpful if we could display individual fields. To do that, "
"use the :attr:`~django.contrib.admin.ModelAdmin.list_display` admin "
"option, which is a tuple of field names to display, as columns, on the "
"change list page for the object:"
msgstr ""

#: ../../intro/tutorial07.txt:204
msgid ""
"Just for good measure, let's also include the "
"``was_published_recently()`` method from :doc:`Tutorial 2 "
"</intro/tutorial02>`:"
msgstr ""

#: ../../intro/tutorial07.txt:214
msgid "Now the question change list page looks like this:"
msgstr ""

#: ../../intro/tutorial07.txt:219
msgid ""
"You can click on the column headers to sort by those values -- except in "
"the case of the ``was_published_recently`` header, because sorting by the"
" output of an arbitrary method is not supported. Also note that the "
"column header for ``was_published_recently`` is, by default, the name of "
"the method (with underscores replaced with spaces), and that each line "
"contains the string representation of the output."
msgstr ""

#: ../../intro/tutorial07.txt:226
msgid ""
"You can improve that by giving that method (in :file:`polls/models.py`) a"
" few attributes, as follows:"
msgstr ""

#: ../../intro/tutorial07.txt:241
msgid ""
"For more information on these method properties, see "
":attr:`~django.contrib.admin.ModelAdmin.list_display`."
msgstr ""

#: ../../intro/tutorial07.txt:244
msgid ""
"Edit your :file:`polls/admin.py` file again and add an improvement to the"
" ``Question`` change list page: filters using the "
":attr:`~django.contrib.admin.ModelAdmin.list_filter`. Add the following "
"line to ``QuestionAdmin``::"
msgstr ""

#: ../../intro/tutorial07.txt:251
msgid ""
"That adds a \"Filter\" sidebar that lets people filter the change list by"
" the ``pub_date`` field:"
msgstr ""

#: ../../intro/tutorial07.txt:257
msgid ""
"The type of filter displayed depends on the type of field you're "
"filtering on. Because ``pub_date`` is a "
":class:`~django.db.models.DateTimeField`, Django knows to give "
"appropriate filter options: \"Any date\", \"Today\", \"Past 7 days\", "
"\"This month\", \"This year\"."
msgstr ""

#: ../../intro/tutorial07.txt:262
msgid "This is shaping up well. Let's add some search capability::"
msgstr ""

#: ../../intro/tutorial07.txt:266
msgid ""
"That adds a search box at the top of the change list. When somebody "
"enters search terms, Django will search the ``question_text`` field. You "
"can use as many fields as you'd like -- although because it uses a "
"``LIKE`` query behind the scenes, limiting the number of search fields to"
" a reasonable number will make it easier for your database to do the "
"search."
msgstr ""

#: ../../intro/tutorial07.txt:272
msgid ""
"Now's also a good time to note that change lists give you free "
"pagination. The default is to display 100 items per page. :attr:`Change "
"list pagination <django.contrib.admin.ModelAdmin.list_per_page>`, "
":attr:`search boxes <django.contrib.admin.ModelAdmin.search_fields>`, "
":attr:`filters <django.contrib.admin.ModelAdmin.list_filter>`, :attr"
":`date-hierarchies <django.contrib.admin.ModelAdmin.date_hierarchy>`, and"
" :attr:`column-header-ordering "
"<django.contrib.admin.ModelAdmin.list_display>` all work together like "
"you think they should."
msgstr ""

#: ../../intro/tutorial07.txt:282
msgid "Customize the admin look and feel"
msgstr ""

#: ../../intro/tutorial07.txt:284
msgid ""
"Clearly, having \"Django administration\" at the top of each admin page "
"is ridiculous. It's just placeholder text."
msgstr ""

#: ../../intro/tutorial07.txt:287
msgid ""
"That's easy to change, though, using Django's template system. The Django"
" admin is powered by Django itself, and its interfaces use Django's own "
"template system."
msgstr ""

#: ../../intro/tutorial07.txt:294
msgid "Customizing your *project's* templates"
msgstr ""

#: ../../intro/tutorial07.txt:296
msgid ""
"Create a ``templates`` directory in your project directory (the one that "
"contains ``manage.py``). Templates can live anywhere on your filesystem "
"that Django can access. (Django runs as whatever user your server runs.) "
"However, keeping your templates within the project is a good convention "
"to follow."
msgstr ""

#: ../../intro/tutorial07.txt:301
msgid ""
"Open your settings file (:file:`mysite/settings.py`, remember) and add a "
":setting:`DIRS <TEMPLATES-DIRS>` option in the :setting:`TEMPLATES` "
"setting:"
msgstr ""

#: ../../intro/tutorial07.txt:323
msgid ""
":setting:`DIRS <TEMPLATES-DIRS>` is a list of filesystem directories to "
"check when loading Django templates; it's a search path."
msgstr ""

#: ../../intro/tutorial07.txt:326
msgid "Organizing templates"
msgstr ""

#: ../../intro/tutorial07.txt:328
msgid ""
"Just like the static files, we *could* have all our templates together, "
"in one big templates directory, and it would work perfectly well. "
"However, templates that  belongs to a particular application, we should "
"put in the application’s template directory (e.g. ``polls/templates``) "
"rather than the project’s (``templates``). We'll discuss in more detail "
"in the :doc:`reusable apps tutorial </intro/reusable-apps>` *why* we do "
"this."
msgstr ""

#: ../../intro/tutorial07.txt:335
msgid ""
"Now create a directory called ``admin`` inside ``templates``, and copy "
"the template ``admin/base_site.html`` from within the default Django "
"admin template directory in the source code of Django itself "
"(``django/contrib/admin/templates``) into that directory."
msgstr ""

#: ../../intro/tutorial07.txt:340
msgid "Where are the Django source files?"
msgstr ""

#: ../../intro/tutorial07.txt:342
msgid ""
"If you have difficulty finding where the Django source files are located "
"on your system, run the following command:"
msgstr ""

#: ../../intro/tutorial07.txt:349
msgid ""
"Then, just edit the file and replace ``{{ site_header|default:_('Django "
"administration') }}`` (including the curly braces) with your own site's "
"name as you see fit. You should end up with a section of code like:"
msgstr ""

#: ../../intro/tutorial07.txt:360
msgid ""
"We use this approach to teach you how to override templates. In an actual"
" project, you would probably use the "
":attr:`django.contrib.admin.AdminSite.site_header` attribute to more "
"easily make this particular customization."
msgstr ""

#: ../../intro/tutorial07.txt:365
msgid ""
"This template file contains lots of text like ``{% block branding %}`` "
"and ``{{ title }}``. The ``{%`` and ``{{`` tags are part of Django's "
"template language. When Django renders ``admin/base_site.html``, this "
"template language will be evaluated to produce the final HTML page, just "
"like we saw in :doc:`Tutorial 3 </intro/tutorial03>`."
msgstr ""

#: ../../intro/tutorial07.txt:371
msgid ""
"Note that any of Django's default admin templates can be overridden. To "
"override a template, just do the same thing you did with "
"``base_site.html`` -- copy it from the default directory into your custom"
" directory, and make changes."
msgstr ""

#: ../../intro/tutorial07.txt:377
msgid "Customizing your *application's* templates"
msgstr ""

#: ../../intro/tutorial07.txt:379
msgid ""
"Astute readers will ask: But if :setting:`DIRS <TEMPLATES-DIRS>` was "
"empty by default, how was Django finding the default admin templates? The"
" answer is that, since :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is set to"
" ``True``, Django automatically looks for a ``templates/`` subdirectory "
"within each application package, for use as a fallback (don't forget that"
" ``django.contrib.admin`` is an application)."
msgstr ""

#: ../../intro/tutorial07.txt:386
msgid ""
"Our poll application is not very complex and doesn't need custom admin "
"templates. But if it grew more sophisticated and required modification of"
" Django's standard admin templates for some of its functionality, it "
"would be more sensible to modify the *application's* templates, rather "
"than those in the *project*. That way, you could include the polls "
"application in any new project and be assured that it would find the "
"custom templates it needed."
msgstr ""

#: ../../intro/tutorial07.txt:393
msgid ""
"See the :ref:`template loading documentation <template-loading>` for more"
" information about how Django finds its templates."
msgstr ""

#: ../../intro/tutorial07.txt:397
msgid "Customize the admin index page"
msgstr ""

#: ../../intro/tutorial07.txt:399
msgid ""
"On a similar note, you might want to customize the look and feel of the "
"Django admin index page."
msgstr ""

#: ../../intro/tutorial07.txt:402
msgid ""
"By default, it displays all the apps in :setting:`INSTALLED_APPS` that "
"have been registered with the admin application, in alphabetical order. "
"You may want to make significant changes to the layout. After all, the "
"index is probably the most important page of the admin, and it should be "
"easy to use."
msgstr ""

#: ../../intro/tutorial07.txt:407
msgid ""
"The template to customize is ``admin/index.html``. (Do the same as with "
"``admin/base_site.html`` in the previous section -- copy it from the "
"default directory to your custom template directory). Edit the file, and "
"you'll see it uses a template variable called ``app_list``. That variable"
" contains every installed Django app. Instead of using that, you can "
"hard-code links to object-specific admin pages in whatever way you think "
"is best."
msgstr ""

#: ../../intro/tutorial07.txt:417
msgid ""
"The beginner tutorial ends here. In the meantime, you might want to check"
" out some pointers on :doc:`where to go from here </intro/whatsnext>`."
msgstr ""

#: ../../intro/tutorial07.txt:420
msgid ""
"If you are familiar with Python packaging and interested in learning how "
"to turn polls into a \"reusable app\", check out :doc:`Advanced tutorial:"
" How to write reusable apps</intro/reusable-apps>`."
msgstr ""

#: ../../intro/whatsnext.txt:3
msgid "What to read next"
msgstr ""

#: ../../intro/whatsnext.txt:5
#, python-format
msgid ""
"So you've read all the :doc:`introductory material </intro/index>` and "
"have decided you'd like to keep using Django. We've only just scratched "
"the surface with this intro (in fact, if you've read every single word, "
"you've read about 5% of the overall documentation)."
msgstr ""

#: ../../intro/whatsnext.txt:10
msgid "So what's next?"
msgstr ""

#: ../../intro/whatsnext.txt:12
msgid ""
"Well, we've always been big fans of learning by doing. At this point you "
"should know enough to start a project of your own and start fooling "
"around. As you need to learn new tricks, come back to the documentation."
msgstr ""

#: ../../intro/whatsnext.txt:16
msgid ""
"We've put a lot of effort into making Django's documentation useful, easy"
" to read and as complete as possible. The rest of this document explains "
"more about how the documentation works so that you can get the most out "
"of it."
msgstr ""

#: ../../intro/whatsnext.txt:20
msgid ""
"(Yes, this is documentation about documentation. Rest assured we have no "
"plans to write a document about how to read the document about "
"documentation.)"
msgstr ""

#: ../../intro/whatsnext.txt:24
msgid "Finding documentation"
msgstr ""

#: ../../intro/whatsnext.txt:26
msgid ""
"Django's got a *lot* of documentation -- almost 450,000 words and "
"counting -- so finding what you need can sometimes be tricky. A few good "
"places to start are the :ref:`search` and the :ref:`genindex`."
msgstr ""

#: ../../intro/whatsnext.txt:30
msgid "Or you can just browse around!"
msgstr ""

#: ../../intro/whatsnext.txt:33
msgid "How the documentation is organized"
msgstr "文档是如何组成"

#: ../../intro/whatsnext.txt:35
msgid ""
"Django's main documentation is broken up into \"chunks\" designed to fill"
" different needs:"
msgstr ""

#: ../../intro/whatsnext.txt:38
msgid ""
"The :doc:`introductory material </intro/index>` is designed for people "
"new to Django -- or to Web development in general. It doesn't cover "
"anything in depth, but instead gives a high-level overview of how "
"developing in Django \"feels\"."
msgstr ""

#: ../../intro/whatsnext.txt:43
msgid ""
"The :doc:`topic guides </topics/index>`, on the other hand, dive deep "
"into individual parts of Django. There are complete guides to Django's "
":doc:`model system </topics/db/index>`, :doc:`template engine "
"</topics/templates>`, :doc:`forms framework </topics/forms/index>`, and "
"much more."
msgstr ""

#: ../../intro/whatsnext.txt:49
msgid ""
"This is probably where you'll want to spend most of your time; if you "
"work your way through these guides you should come out knowing pretty "
"much everything there is to know about Django."
msgstr ""

#: ../../intro/whatsnext.txt:53
msgid ""
"Web development is often broad, not deep -- problems span many domains. "
"We've written a set of :doc:`how-to guides </howto/index>` that answer "
"common \"How do I ...?\" questions. Here you'll find information about "
":doc:`generating PDFs with Django </howto/outputting-pdf>`, :doc:`writing"
" custom template tags </howto/custom-template-tags>`, and more."
msgstr ""

#: ../../intro/whatsnext.txt:59
msgid ""
"Answers to really common questions can also be found in the :doc:`FAQ "
"</faq/index>`."
msgstr ""

#: ../../intro/whatsnext.txt:62
msgid ""
"The guides and how-to's don't cover every single class, function, and "
"method available in Django -- that would be overwhelming when you're "
"trying to learn. Instead, details about individual classes, functions, "
"methods, and modules are kept in the :doc:`reference </ref/index>`. This "
"is where you'll turn to find the details of a particular function or "
"whatever you need."
msgstr ""

#: ../../intro/whatsnext.txt:69
msgid ""
"If you are interested in deploying a project for public use, our docs "
"have :doc:`several guides</howto/deployment/index>` for various "
"deployment setups as well as a :doc:`deployment "
"checklist</howto/deployment/checklist>` for some things you'll need to "
"think about."
msgstr ""

#: ../../intro/whatsnext.txt:74
msgid ""
"Finally, there's some \"specialized\" documentation not usually relevant "
"to most developers. This includes the :doc:`release notes "
"</releases/index>` and :doc:`internals documentation </internals/index>` "
"for those who want to add code to Django itself, and a :doc:`few other "
"things that simply don't fit elsewhere </misc/index>`."
msgstr ""

#: ../../intro/whatsnext.txt:82
msgid "How documentation is updated"
msgstr ""

#: ../../intro/whatsnext.txt:84
msgid ""
"Just as the Django code base is developed and improved on a daily basis, "
"our documentation is consistently improving. We improve documentation for"
" several reasons:"
msgstr ""

#: ../../intro/whatsnext.txt:88
msgid "To make content fixes, such as grammar/typo corrections."
msgstr ""

#: ../../intro/whatsnext.txt:90
msgid ""
"To add information and/or examples to existing sections that need to be "
"expanded."
msgstr ""

#: ../../intro/whatsnext.txt:93
msgid ""
"To document Django features that aren't yet documented. (The list of such"
" features is shrinking but exists nonetheless.)"
msgstr ""

#: ../../intro/whatsnext.txt:96
msgid ""
"To add documentation for new features as new features get added, or as "
"Django APIs or behaviors change."
msgstr ""

#: ../../intro/whatsnext.txt:99
msgid ""
"Django's documentation is kept in the same source control system as its "
"code. It lives in the `docs`_ directory of our Git repository. Each "
"document online is a separate text file in the repository."
msgstr ""

#: ../../intro/whatsnext.txt:106
msgid "Where to get it"
msgstr ""

#: ../../intro/whatsnext.txt:108
msgid ""
"You can read Django documentation in several ways. They are, in order of "
"preference:"
msgstr ""

#: ../../intro/whatsnext.txt:112
msgid "On the Web"
msgstr ""

#: ../../intro/whatsnext.txt:114
msgid ""
"The most recent version of the Django documentation lives at "
"https://docs.djangoproject.com/en/dev/. These HTML pages are generated "
"automatically from the text files in source control. That means they "
"reflect the \"latest and greatest\" in Django -- they include the very "
"latest corrections and additions, and they discuss the latest Django "
"features, which may only be available to users of the Django development "
"version. (See \"Differences between versions\" below.)"
msgstr ""

#: ../../intro/whatsnext.txt:122
msgid ""
"We encourage you to help improve the docs by submitting changes, "
"corrections and suggestions in the `ticket system`_. The Django "
"developers actively monitor the ticket system and use your feedback to "
"improve the documentation for everybody."
msgstr ""

#: ../../intro/whatsnext.txt:126
msgid ""
"Note, however, that tickets should explicitly relate to the "
"documentation, rather than asking broad tech-support questions. If you "
"need help with your particular Django setup, try the |django-users| "
"mailing list or the `#django IRC channel`_ instead."
msgstr ""

#: ../../intro/whatsnext.txt:135
msgid "In plain text"
msgstr ""

#: ../../intro/whatsnext.txt:137
msgid ""
"For offline reading, or just for convenience, you can read the Django "
"documentation in plain text."
msgstr ""

#: ../../intro/whatsnext.txt:140
msgid ""
"If you're using an official release of Django, note that the zipped "
"package (tarball) of the code includes a ``docs/`` directory, which "
"contains all the documentation for that release."
msgstr ""

#: ../../intro/whatsnext.txt:144
msgid ""
"If you're using the development version of Django (aka \"trunk\"), note "
"that the ``docs/`` directory contains all of the documentation. You can "
"update your Git checkout to get the latest changes."
msgstr ""

#: ../../intro/whatsnext.txt:148
msgid ""
"One low-tech way of taking advantage of the text documentation is by "
"using the Unix ``grep`` utility to search for a phrase in all of the "
"documentation. For example, this will show you each mention of the phrase"
" \"max_length\" in any Django document:"
msgstr ""

#: ../../intro/whatsnext.txt:158
msgid "As HTML, locally"
msgstr ""

#: ../../intro/whatsnext.txt:160
msgid ""
"You can get a local copy of the HTML documentation following a few easy "
"steps:"
msgstr ""

#: ../../intro/whatsnext.txt:162
msgid ""
"Django's documentation uses a system called Sphinx__ to convert from "
"plain text to HTML. You'll need to install Sphinx by either downloading "
"and installing the package from the Sphinx website, or with ``pip``:"
msgstr ""

#: ../../intro/whatsnext.txt:170
msgid ""
"Then, just use the included ``Makefile`` to turn the documentation into "
"HTML:"
msgstr ""

#: ../../intro/whatsnext.txt:178
msgid "You'll need `GNU Make`__ installed for this."
msgstr ""

#: ../../intro/whatsnext.txt:180
msgid "If you're on Windows you can alternatively use the included batch file:"
msgstr ""

#: ../../intro/whatsnext.txt:187
msgid "The HTML documentation will be placed in ``docs/_build/html``."
msgstr ""

#: ../../intro/whatsnext.txt:191
msgid ""
"Generation of the Django documentation will work with Sphinx version 0.6 "
"or newer, but we recommend going straight to Sphinx 1.0.2 or newer."
msgstr ""

#: ../../intro/whatsnext.txt:200
msgid "Differences between versions"
msgstr "版本之间的差异"

#: ../../intro/whatsnext.txt:202
msgid ""
"As previously mentioned, the text documentation in our Git repository "
"contains the \"latest and greatest\" changes and additions. These changes"
" often include documentation of new features added in the Django "
"development version -- the Git (\"trunk\") version of Django. For that "
"reason, it's worth pointing out our policy on keeping straight the "
"documentation for various versions of the framework."
msgstr ""

#: ../../intro/whatsnext.txt:209
msgid "We follow this policy:"
msgstr ""

#: ../../intro/whatsnext.txt:211
msgid ""
"The primary documentation on djangoproject.com is an HTML version of the "
"latest docs in Git. These docs always correspond to the latest official "
"Django release, plus whatever features we've added/changed in the "
"framework *since* the latest release."
msgstr ""

#: ../../intro/whatsnext.txt:216
msgid ""
"As we add features to Django's development version, we try to update the "
"documentation in the same Git commit transaction."
msgstr ""

#: ../../intro/whatsnext.txt:219
msgid ""
"To distinguish feature changes/additions in the docs, we use the phrase: "
"\"New in version X.Y\", being X.Y the next release version (hence, the "
"one being developed)."
msgstr ""

#: ../../intro/whatsnext.txt:223
msgid ""
"Documentation fixes and improvements may be backported to the last "
"release branch, at the discretion of the committer, however, once a "
"version of Django is :ref:`no longer supported<backwards-compatibility-"
"policy>`, that version of the docs won't get any further updates."
msgstr ""

#: ../../intro/whatsnext.txt:228
msgid ""
"The `main documentation Web page`_ includes links to documentation for "
"all previous versions. Be sure you are using the version of the docs "
"corresponding to the version of Django you are using!"
msgstr ""

#~ msgid ""
#~ "This advanced tutorial begins where "
#~ ":doc:`Tutorial 6 </intro/tutorial06>` left "
#~ "off. We'll be turning our Web-poll"
#~ " into a standalone Python package you"
#~ " can reuse in new projects and "
#~ "share with other people."
#~ msgstr ""

#~ msgid ""
#~ "If you haven't recently completed "
#~ "Tutorials 1–6, we encourage you to "
#~ "review these so that your example "
#~ "project matches the one described below."
#~ msgstr ""

#~ msgid ""
#~ "When somebody requests a page from "
#~ "your website -- say, \"/polls/34/\", "
#~ "Django will load the ``mysite.urls`` "
#~ "Python module because it's pointed to"
#~ " by the :setting:`ROOT_URLCONF` setting. It"
#~ " finds the variable named ``urlpatterns``"
#~ " and traverses the regular expressions "
#~ "in order. The :func:`~django.conf.urls.include` "
#~ "functions we are using simply reference"
#~ " other URLconfs. Note that the "
#~ "regular expressions for the "
#~ ":func:`~django.conf.urls.include` functions don't "
#~ "have a ``$`` (end-of-string match"
#~ " character) but rather a trailing "
#~ "slash. Whenever Django encounters "
#~ ":func:`~django.conf.urls.include`, it chops off "
#~ "whatever part of the URL matched "
#~ "up to that point and sends the "
#~ "remaining string to the included URLconf"
#~ " for further processing."
#~ msgstr ""
#~ "当某人请求你网站的某一页面时——比如说， \"/polls/34/\" ，Django 将会载入 "
#~ "``mysite.urls`` 模块，因为配置项  :setting:`ROOT_URLCONF` "
#~ "说要载入它。然后 Django 寻找名为 ``urlpatterns``  "
#~ "变量并且按序遍历正则表达式。我们使用的 :func:`~django.conf.urls.include`  "
#~ "函数只是简单的引用其他的 :func:`~django.conf.urls.include` 文件。请注意 "
#~ ":func:`~django.conf.urls.include`  函数的正则表达式不包含 $ "
#~ "符号(匹配字符串结尾)但是结尾有斜线。当 Django 遇到一个 "
#~ ":func:`~django.conf.urls.include` "
#~ "，它砍掉被正则表达式匹配上的部分，并把剩余的字符串发送个作为参数的 URLconf 做进一步处理。"

#~ msgid "Here's what happens if a user goes to \"/polls/34/\" in this system:"
#~ msgstr "下面的流程介绍了当用户访问 \"/polls/34/\" 时，系统里依次发生了什么："

#~ msgid "Django will find the match at ``'^polls/'``"
#~ msgstr "Django 找到匹配的正则表达式 ``'^polls/'``"

#~ msgid ""
#~ "Then, Django will strip off the "
#~ "matching text (``\"polls/\"``) and send "
#~ "the remaining text -- ``\"34/\"`` -- "
#~ "to the 'polls.urls' URLconf for further"
#~ " processing which matches "
#~ "``r'^(?P<question_id>[0-9]+)/$'`` resulting in a "
#~ "call to the ``detail()`` view like "
#~ "so::"
#~ msgstr ""
#~ "然后。Django 将会去除被匹配的部分( ``\"polls/\"`` ),然后发送剩下的文本——"
#~ " ``\"34/\"`` ——给 'polls.urls' 这个 URLconf"
#~ " 做进一步处理。然后找到匹配的正则表达式 ``r'^(?P<question_id>[0-9]+)/$'`` "
#~ "，随后用以下方式调用  ``detail()`` 函数："

#~ msgid ""
#~ "``{% load staticfiles %}`` loads the "
#~ ":ttag:`{% static %} <staticfiles-static>` "
#~ "template tag from the ``staticfiles`` "
#~ "template library. The ``{% static %}``"
#~ " template tag generates the absolute "
#~ "URL of the static file."
#~ msgstr ""

#~ msgid ""
#~ "You'll follow this pattern -- create "
#~ "a model admin class, then pass it"
#~ " as the second argument to "
#~ "``admin.site.register()`` -- any time you "
#~ "need to change the admin options "
#~ "for an model."
#~ msgstr ""

